//1. Einbindung der Bibliotheken 
//Standard-Bibiliotheken
#include <Arduino.h>   //Arduino-Standardlib
#include <stdio.h>     //TODO
#include <EEPROM.h>   //SPeicherungen der Variablen (z.B.Sollwert)
#include <OneWire.h>  //Bibliothek für 1-Leiter-Bussysteme (Wassertemp. / DHT11)
#include <SPI.h>      //TODO
#include <Wire.h>     //I2C

//Bibliotheken für NEXTION-Display
#include <EasyNextionLibrary.h>

//Bibliotheken für Umgebungssensoren & Luftqualitätsmessung (I2C)
#include <Adafruit_CCS811.h>          //Bibliothek für CO2-Sensor (I2C) 
Adafruit_CCS811 ccs;
#include <ClosedCube_HDC1080.h>       //Bibliothek für Feuchte und Temp.sensor (I2C)
ClosedCube_HDC1080 hdc1080;
#include <DHT.h>                      //Bibliothek für Einbindung DHT11 Sensoren (ONEBUSWIRE)
#include <DallasTemperature.h>

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//2.	Variablen, Deklarationen, Makros (Textersetzungen)

//Hinweis: auch Zuweisungen der digitalen Ein- und Ausgänge

//DHT11 Temperatur und Feuchtesensoren
//Technikebene
#define DHTPIN1 10          //Angabe des verwendeten PIN´s
//NFT-Ebene
#define DHTPIN2 30          //Angabe des verwendeten PIN´s
//Sensorentyp festlegen
#define DHTTYPE DHT11       //Angabe des verwendeten PIN´s
//Zuweisung des Sensortyps und Pins
DHT dht1(DHTPIN1, DHTTYPE);           //Sensor in der Technikebene -12B1 
DHT dht2(DHTPIN2, DHTTYPE);           //Sensor im NFT-Bereich / -16B1 für die Mittelwertbildung
//-------------------------------------------------------------------------------------------------------------------------------------
//Füllstandsensor für Volumenmessung
const int trigPin = 25;         //Ultraschall senden
const int echoPin = 26;         //Ultrasschall empfangen
//-------------------------------------------------------------------------------------------------------------------------------------
//PH-Messung
#define SensorPin A0            //Analoger Eingang für das Auslesen des pH-Wertes
#define offsetPH -0.2           //Abweichung hier kompensieren
#define ArrayLenthPH 10         //Anzahl der Datenspeicher im Array um den Mittelwert des PH-Wertes zu ermitteln
//-------------------------------------------------------------------------------------------------------------------------------------
//Leckageüberwachung
#define leakage 27              //Meldung Leckage
//-------------------------------------------------------------------------------------------------------------------------------------
//Digitale Ausgänge
//Pumpen
#define pumpNFT 2               //Hauptpumpe
bool pumpNFTstatus = false;     //Hauptpumpe Hilfsmerker --> Speicherung des des Steuerstatus: EIN oder AUS
#define pumpEC 7                //Dosierpumpe EC
#define pumpPH 6                //Dosierpumpe PH
//Lüftung
#define ventilator 5            //Ablüfter
//Beleuchtung
#define lightNFT 3              //NFT-Licht
#define lightGrowing 4          //Anzucht-Licht  
//Status-LED (RUN)
# define LED 13  
//-------------------------------------------------------------------------------------------------------------------------------------
//Terminal Fühler - Wassertemperatur
#define ONE_WIRE_BUS 8                //Datenpin vom Temp.Sensor
OneWire oneWire(ONE_WIRE_BUS);        //Buskommunikation Sensor
DallasTemperature sensors(&oneWire);  //Buskommunikation Sensor
//-------------------------------------------------------------------------------------------------------------------------------------
//Schnittstelle einstellen für das NEXTION-Display (RX1/TX1)
EasyNex myNex(Serial1);
//-------------------------------------------------------------------------------------------------------------------------------------
//Anlagenvariablen des Displays (z.B. Grenzwerte, Zeit für die Steuerung der Beleuchtung, usw.)
//EEPROM-Variablen zur Speicherung müssen vor dem Setup stehen

//Zeitsteuerung NFT
int Start_lightNFT_hour = 7;            //Einschaltzeit NFT-Beleuchtung(Stunden)
int Start_lightNFT_minute = 0;          //Einschaltzeit NFT-Beleuchtung(Minuten)
int Stopp_lightNFT_hour = 19;           //Ausschaltzeit NFT-Beleuchtung(Stunden)
int Stopp_lightNFT_minute = 0;          //Ausschaltzeit NFT-Beleuchtung(Minuten)

//Zeitsteuerung Anzucht
int Start_lightGrowing_hour = 7;        //Einschaltzeit NFT-Beleuchtung(Stunden)
int Start_lightGrowing_minute = 0;      //Einschaltzeit NFT-Beleuchtung(Minuten)
int Stopp_lightGrowing_hour = 19;       //Ausschaltzeit NFT-Beleuchtung(Stunden)
int Stopp_lightGrowing_minute = 0;      //Ausschaltzeit NFT-Beleuchtung(Minuten)

//Zeitsteuerung NFT und Anzucht Beleuchtung
int iLight40FH = Start_lightNFT_hour;       //NFT Licht Einschaltdauer von (Stunden)
int iLight40FM = Start_lightNFT_minute;     //NFT Licht Einschaltdauer von (Minuten)
int iLight40TH = Stopp_lightNFT_hour;       //NFT Licht Einschaltdauer bis (Stunden)
int iLight40TM = Stopp_lightNFT_minute;     //NFT Licht Einschaltdauer bis (Minuten)
int iLight20FH = Start_lightGrowing_hour;   //Anzucht Licht Einschaltdauer von (Stunden)
int iLight20FM = Start_lightGrowing_minute; //Anzucht Licht Einschaltdauer von (Minuten)
int iLight20TH = Stopp_lightGrowing_hour;   //Anzucht Licht Einschaltdauer bis (Stunden)
int iLight20TM = Stopp_lightGrowing_minute; //Anzucht Licht Einschaltdauer bis (Minuten)

//Freigaben für die Verschaltung im MAIN-LOOP
int ANLAGE = 0;
int DOSIERUNG = 0;

//Einschaltzyklus (in Minuten)
int iPumpOn = 0;                       

//Standby Zeit des NEXTIONI-Displays(in Sekunden)
int iStandby = 0;                          

//Sollwerte / Grenzwerte 
//Belüftung
float flSollPlantMois=0;                //Grenzwert Feuchte Pflanzen
float flSollPlantTemp=0 ;               //Grenzwert Temperatur Pflanzen
float flSollCO2=0;                      //Grenzwert CO2

//Dosierung
float flSollPH = 0;                     //GrenzwertPH  
float flSollEC = 0;                     //GrenzwertEC

//-------------------------------------------------------------------------------------------------------------------------------------
//Variablen für die EC-Messung
//Hinweis: Die Variablen müssen vor dem Setup angelegt werden (--> Kalbrierungsfunktion wird im Setup aufgerufen)
int R1= 1000;               //Wert des Widerstandes für die EC-Messung über den Stecker (1kOhm)
int EC_Read = A2;           //AI: Analoger Wert über Spannungsteiler auslesen 
int ECPower = A1;           //AO: 5V Spannung über den Stecker ins Wasser geleitet
float Temp_C;               //Temp in Celcius
float Temp_F;               //Temp in Fahrenheit für internationalen Standard (Vorhaltung)
float Temp1_Value = 0;      //Speicherwert für die Vergleichsmessung
float Temp_Coef = 0.019;    //Temperatur Koeffizient 
float offsetTempEC=-0.3;    //Temperaturoffset --> abgeglichen mit EC/PPM/PH-Messgerät
float Temperature;          //gemessene Temperatur über Terminalfühler
float EC;                   //Errechneter EC-Wert
float offsetEC = -0.215;    //Kompenstation EC (invertierte Logik)
float EC_at_25 = 0;         //EC-Wert bei 25 Grad
int ppm = 0;                //Errechneter Wert der Anzahl der Teilchen der Lösung in PartsPerMillion
float A_to_D= 0;            //Analog-Digital-Wandlung
float Vin= 5;               //angegebener Wert der Spannung für die Messung
float Vdrop= 0;             //Angabe für Rechteckssignal
float R_Water;              //Widerstand des Wassers
float Value=0;              //Speicherung des Zwischenwerts

//Relevant NUR für Kalibrierung (ACHTUNG!)
float Calibration_PPM = 600;                    //gemessener Wert über ein geeichtes Messgerät oder der geeichten Pufferlösung
float K_factor= 0.075;                          //Abgleichfaktor (Kompensation)
float PPM_Con=0.5;                              //TDS Factor --> im Datenblatt des externen Messgerätes enthalten (unterschiedliche Normen weltweit)
float CalibrationEC= (Calibration_PPM*2)/1000;  //Vergleich für die EC-Messung


//3. Setup
void setup() { 
pinMode(LED,OUTPUT);          //RUN-LED --> Überprüfung ob Programm läuft
//-------------------------------------------------------------------------------------------------------------------------------------
getfromEEPROM();              //EEPROM - Werte aus dem Speicher lesen
//-------------------------------------------------------------------------------------------------------------------------------------
//Seriellen Schnittstellen
Serial.begin (9600);          //Beginn der Seriellen Schnittstelle / Bautrate: 9600
myNex.begin(9600);            //Beginn der Seriellen Schnittstelle fürs NEXTION-Display
//-------------------------------------------------------------------------------------------------------------------------------------
//Umgebungstemperatur Sensor DHT11 INIT (-12B1 & -16B1) 
dht1.begin();
dht2.begin(); 
//-------------------------------------------------------------------------------------------------------------------------------------
//I2C - INIT
Wire.begin();
//-------------------------------------------------------------------------------------------------------------------------------------
//Wassertemperatursensor für EC-Berechnung (-11B2)
sensors.begin();                        //Initialisierung 
sensors.requestTemperatures();          //Werte des Terminalfühlers ausgeben
//-------------------------------------------------------------------------------------------------------------------------------------
//Temperatur und Feuchte des Kombifühlers INIT (-17B1)
hdc1080.begin(0x40);
//-------------------------------------------------------------------------------------------------------------------------------------
//Gassensor INIT (-17B1)
ccs.begin();                            //Initialisierung

//Abfrage ob der Sensor gefunden wird
if(!ccs.begin()){                      
Serial.println("Sensor konnte nicht gestartet werden. Verdrahtung prüfen !");
while(1);
}
while(!ccs.available());                //Auf Sensor warten
//-------------------------------------------------------------------------------------------------------------------------------------
//Festlegung PINS (Arduino-MEGA 2560)
//(in "2.	Variablen, Deklarationen und  Makros (Textersetzungen)" ist die Beschreibung vorhanden )
//EC-Messung
pinMode(EC_Read,INPUT);
pinMode(ECPower,OUTPUT);
//-------------------------------------------------------------------------------------------------------------------------------------
//Füllstland (Ultraschallsensor)
pinMode(trigPin,OUTPUT); 
pinMode(echoPin,INPUT);
//-------------------------------------------------------------------------------------------------------------------------------------
//Leckageüberwachung
pinMode(leakage, INPUT_PULLUP);
//-------------------------------------------------------------------------------------------------------------------------------------
//Zuweisung NFT-System  -   Pumpen, Lüfter und Beleuchtung des Systems
//Pumpen
pinMode(pumpNFT,OUTPUT);          //Hauptpumpe  NFT
digitalWrite(pumpNFT, HIGH);      //Relais Anfgangsinitialisierung
pinMode(pumpEC,OUTPUT);           //EC-Pumpe
digitalWrite(pumpEC, HIGH);       //Relais Anfgangsinitialisierung
pinMode(pumpPH,OUTPUT);           //PH-Pumpe
digitalWrite(pumpPH, HIGH);       //Relais Anfgangsinitialisierung

//Lüftung
pinMode(ventilator,OUTPUT);       //Ablüfter
digitalWrite(ventilator, HIGH);   //Relais Anfgangsinitialisierung

//Beleuchtung
pinMode(lightNFT,OUTPUT);         //NFT-Beleuchtung (40 Watt)
digitalWrite(lightNFT,HIGH);      //Relais Anfgangsinitialisierung
pinMode(lightGrowing,OUTPUT);     //Anzucht-Beleuchtung (20 Watt)
digitalWrite(lightGrowing,HIGH);  //Relais Anfgangsinitialisierung
//-------------------------------------------------------------------------------------------------------------------------------------
//EC-Messung Kalibrierung (ACHTUNG!) --> zu Beginn des Systems Kalbrieren
//Muss nach der Kalibrierung auskommentiert werden
//Calibrate (0,0);  
//-------------------------------------------------------------------------------------------------------------------------------------
//Timer für die Intervallzyklus, Uhrzeit, Dosierung
//Konfiguration Timer 1
  TCCR1A = 0;                         //Register A --> OC1A/OC1B
  TCCR1B = 0;                         //INIT Register B
  TCCR1B |= (1<<CS10)|(1 << CS12);    //PRESCALER: 1024 --> CS10 = 1 , CS12 = 1
  TCNT1 = 0xC2F8;                     //Beginn des Zählzyklus
                                      //65536-(16MHz/1024/1Hz - 1) = 49912 = 0xC2F8 (Ergebnis in HEX)
  TIMSK1 |= (1 << TOIE1);             //Interruptregister
} 

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//4. Funktionen & Variablen der jeweiligen Funktionen

//4.1.	Erstellung einer Uhrzeit für Zeitsteuerung und Anzeige der Uhrzeit
volatile int zaehler_sek =0;
volatile int zaehler_min = 4 ; 
volatile int zaehler_hour = 18;
//volatile int zaehler_day = 5; (Vorhaltung für Datum)

//Interrupt-Routine
//Generieren des Timers um Steuerbefehle über die Zeit auszuführen und Uhrzeit darzustellen
ISR(TIMER1_OVF_vect)                              //Interruptbefehl bei einer Sekunde
{
  TCNT1 = 0xC2F7;                                 //Startwert für Timer1 Register
  zaehler_sek=zaehler_sek + 1;
  if (zaehler_sek==60){                           //Sekunden
    zaehler_sek = 0;
    zaehler_min =zaehler_min + 1;
  }
  if (zaehler_min == 60){                         //Minuten
    zaehler_min = 0;
    zaehler_hour= zaehler_hour+1;
  }
  if (zaehler_hour == 24){                        //Stunden
    zaehler_hour = 0;
    //zaehler_day = zaehler_day + 1; (Vorhaltung für Datumsgenerierung)
  }
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//4.2.	Störmeldeliste – Initialisierung der Meldungen und Angabe der Grenzwerte (minimal und maximal) für Störungen der Sensoren
//--> Angabe der unteren und oberen Grenzwerte für die Störungsausgabe

//Variablen für das Display 
// --> INITIALISIERUNG (fehlerfrei!)
//Störung = 10 oder in Ordnung = 9
int Pic_PlantSensL = 9;
int Pic_PlantSensR = 9;
int Pic_BotSens = 9;
int Pic_EC = 9;
int Pic_PH = 9;
int Pic_Watertemp = 9;
int Pic_Waterlevel = 9;

//Alarm 1 - NFT-Temperatur- & -Feuchte (-16B1) 
float GW_PlantTempL_max = 30;   //Grenzwert Temperatur (MAX & MIN)
float GW_PlantTempL_min = 10;
float GW_PlantMoistL_max = 90;  //Grenzwert Feuchte (MAX & MIN)
float GW_PlantMoistL_min = 10;

//Alarm 2 - NFT-Temperatur-, -Feuchte & CO2 (-17B1) 
float GW_PlantTempR_max = 30;   //Grenzwert Temperatur (MAX & MIN)
float GW_PlantTempR_min = 10;
float GW_PlantMoistR_max = 90;  //Grenzwert Feuchte (MAX & MIN)
float GW_PlantMoistR_min = 10;
float GW_PlantCO2R_max = 4500;  //Grenzwert CO2 (MAX & MIN)
float GW_PlantCO2R_min = 399;

//Alarm 3 - Technik-Temperatur und -Feuchte (-12B1)
float GW_BotTemp_max = 30;      //Grenzwert Temperatur (MAX & MIN)
float GW_BotTemp_min = 5;
float GW_BotMoist_max = 90;     //Grenzwert Feuchte (MAX & MIN)
float GW_BotMoist_min = 10;

//Alarm 4 - PH-Sensor
float GW_PH_Value_max = 10;     //Grenzwert pH (MAX & MIN)
float GW_PH_Value_min = 5.0;

//Alarm 5 - EC-Sensor
float GW_EC_Value_max = 2.5;    //Grenzwert EC (MAX & MIN)
float GW_EC_Value_min = 0;

//Alarm 6 - Wassertemperatur-Sensor (EC)
float GW_Watertemp_max = 25;    //Grenzwert EC-Wassertemp (MAX & MIN)
float GW_Watertemp_min = 10;

//Alarm 7 - Volumenmessung des Tanks
float GW_Waterlevel_max = 60;   //Grenzwert Füllstandsmessung (MAX & MIN)
float GW_Waterlevel_min = 20;

//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//4.3. Leckageüberwachung 

//Variablen Leckageüberwachung
bool Merker_Leakage = false;      //Hilfsmerker für Flankensteuerung
bool Reset_Leakage = 0;           //Status des Reset-Buttons auf dem NEXTION-Display
//Fehlermeldungen fürs Display
int Pic_Leckage = 9;              //Display-Parameter: Störung nicht aktiv
int Pic_Indicator = 7;            //Display-Parameter: INIT Symbol

void leakageDetection(){
  if((digitalRead(leakage)) == LOW){        //wenn Leckage detektiert --> ALLE Ansteuerungen der Pumpen (NFT + Dosierung) ausschalten & akustischen Alarm auslösen
    digitalWrite(pumpNFT,HIGH);           
    digitalWrite(pumpPH,HIGH);            
    digitalWrite(pumpEC,HIGH);
    Merker_Leakage = true;                  //einmalig auslöst (Selbsthaltung) --> Quittierung erforderlich
    Pic_Leckage = 10;                       //Display-Parameter: Störung aktiv
    SetAlarm();                             //Alarmausgabe visuell & akustisch aktivieren
  }
  
  //Quittierung der Leckage über den RESET-Button des Displays 
  if(Reset_Leakage == 1){                   //wenn RESET-Button gedrückt 
    if(digitalRead(leakage) == LOW){        //wenn Leckage noch vorhanden
      Merker_Leakage = true;
      Reset_Leakage = 0;
    }
    if(digitalRead(leakage) == HIGH){       //wenn Leckage nicht mehr vorhanden
      Merker_Leakage = false;
      Reset_Leakage = 0;
      Pic_Leckage = 9;                      //Display-Parameter: Störung nicht aktiv
      QuitAlarm();                          //Alarmausgabe visuell & akustisch deaktivieren
    }
  }
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//4.4. Füllstandsüberwachung
//Füllstandsmessung
int duration=0 ;                            //Länge der Messungen
int distance= 0;                            //Entfernung in cm
int distanceWithoutFailure = 0;             //Fehlereingrenzung durch Wellen

int trigStateUltraSens = LOW;               //Status des Triggers
int intervalUltraSens = 2;                  //Intervall in millisek --> Einschalten des Triggers
int interval2UltraSens = 1000;              //Ausgabeintervall (seriell)
int printStateUltraSens = LOW;              //Ausgabe als PRINT-Befehl oder anderen seriellen Schnittstelle (JA/NEIN)
unsigned long previousMillisUltraSens = 0;  //vorheriger Wert mit dem der nächste Wert verknüpfen

//Maße des zu messenden Behälters
float height = 0.32;                                                    //Höhe des Tanks    (Einheit: meter)
float depth = 0.367;                                                    //Tiefe des Tanks   (Einheit: meter)
float width= 0.565;                                                     //Breite des Tanks  (Einheit: meter)
float offsetTanklevel = 2;                                              //Offset für genauere Kalbrierung (Einheit: liter)
float volume_tank_ges = ((height*width*depth)*1000) - offsetTanklevel;  //Volumen des gesamten Tankes
float volume_tank_cal = 0;                                              //Berechnung des momentanigen Wasservolumens

//Funktion Mittelwertbildung Füllstand
const int arraySizeWaterlevel = 10;                          
float measuringWaterlevel[arraySizeWaterlevel] = {0};
float measureWaterlevel = 0;                          //Volumenerrechnung
float averageWaterlevel = 0;                          //Übergabe Mittelwert
float sumWaterlevel = 0;                              //Ausgerechnet Summe für den Mittelwert

//Mittelwertbildung von Wasservolumen im Tank
void average_calculation_Waterlevel(){
  measureWaterlevel = volume_tank_cal;                                  //Übergabe Messwert
  for (int i = 0; i < arraySizeWaterlevel - 1; i++) {
    measuringWaterlevel[i] = measuringWaterlevel[i+1];
  }
  measuringWaterlevel[arraySizeWaterlevel - 1] = measureWaterlevel;
  sumWaterlevel= 0;                                                     //Berechnung des Mittelwerts aus allen Messungen
  for (int i = 0; i < arraySizeWaterlevel; i++) {
    sumWaterlevel += measuringWaterlevel[i];
  }
  averageWaterlevel = sumWaterlevel / arraySizeWaterlevel;
  return averageWaterlevel;
}

//------------------------------------------------------------------------------------------------------------------

//4.5. Zeitsteuerung von Beleuchtung und Zirkulationspumpe (Vorhaltung)

//Steuerung der Beleuchtung im NFT-Bereich über die Uhrzeit
void lightNFT_timecontrol(){
    if ( zaehler_hour>= 0 && zaehler_hour < Start_lightNFT_hour){                             //Von 0Uhr bis 14Uhr
      digitalWrite(lightNFT, HIGH); //Aus
    }
    else if (zaehler_hour == Start_lightNFT_hour && zaehler_min < Start_lightNFT_minute){     //Von 14Uhr bis 14:29Uhr
      digitalWrite(lightNFT, HIGH); //Aus
    }
    else if (Start_lightNFT_hour != Stopp_lightNFT_hour && zaehler_hour == Start_lightNFT_hour && zaehler_min >= Start_lightNFT_minute){ //Von 14:30 bis 15Uhr
      digitalWrite(lightNFT, LOW);  //Ein
    }
    else if (zaehler_hour > Start_lightNFT_hour && zaehler_hour < Stopp_lightNFT_hour){       //Von 15Uhr bis 19Uhr
      digitalWrite(lightNFT, LOW);  //Ein
    }
    else if (zaehler_hour == Stopp_lightNFT_hour && zaehler_min < Stopp_lightNFT_minute){     //Von 20Uhr bis 20:49Uhr
      digitalWrite(lightNFT, LOW);  //Ein
    }
    else if (zaehler_hour == Stopp_lightNFT_hour && zaehler_min >= Stopp_lightNFT_minute){    //Von 20:50Uhr bis 21Uhr
      digitalWrite(lightNFT, HIGH); //Aus
    }   
    else if (zaehler_hour > Stopp_lightNFT_hour && zaehler_hour <= 23){                       //Von 21Uhr bis 23:59Uhr
      digitalWrite(lightNFT, HIGH); //Aus
    }
    //Innerhalb einer Stunde (für einige Minuten)
    if (Start_lightNFT_hour == Stopp_lightNFT_hour){
      if (zaehler_min >= Start_lightNFT_minute && zaehler_min < Stopp_lightNFT_minute){
        digitalWrite(lightNFT, LOW);  //Ein
      }
      else {
        digitalWrite(lightNFT, HIGH);  //Aus
      }
    }

}

//Steuerung der Beleuchtung im Anzuchts-Bereich über die Uhrzeit
void lightGrowing_timecontrol(){
    if (zaehler_hour >= 0 && zaehler_hour < Start_lightGrowing_hour){                                     //Von 0Uhr bis 14Uhr
      digitalWrite(lightGrowing, HIGH); //Aus
    }
    else if (zaehler_hour == Start_lightGrowing_hour && zaehler_min < Start_lightGrowing_minute){         //Von 14Uhr bis 14:29Uhr
      digitalWrite(lightGrowing, HIGH); //Aus
    }
    else if (Start_lightGrowing_hour != Stopp_lightGrowing_hour && zaehler_hour == Start_lightGrowing_hour && zaehler_min >= Start_lightGrowing_minute){ //Von 14:30 bis 15Uhr
      digitalWrite(lightGrowing, LOW);  //Ein
    }
    else if (zaehler_hour > Start_lightGrowing_hour && zaehler_hour < Stopp_lightGrowing_hour){           //Von 15Uhr bis 19Uhr
      digitalWrite(lightGrowing, LOW);  //Ein
    }
    else if (zaehler_hour == Stopp_lightGrowing_hour && zaehler_min < Stopp_lightGrowing_minute){         //Von 20Uhr bis 20:49Uhr
      digitalWrite(lightGrowing, LOW);  //Ein
    }
    else if (zaehler_hour == Stopp_lightGrowing_hour && zaehler_min >= Stopp_lightGrowing_minute){        //Von 20:50Uhr bis 21Uhr
      digitalWrite(lightGrowing, HIGH); //Aus
    }   
    else if (zaehler_hour > Stopp_lightGrowing_hour && zaehler_hour <= 23){                               //Von 21Uhr bis 23:59Uhr
      digitalWrite(lightGrowing, HIGH); //Aus
    }
    //Innerhalb einer Stunde (wenige Minuten)
    if (Start_lightGrowing_hour == Stopp_lightGrowing_hour){
      if (zaehler_min >= Start_lightGrowing_minute && zaehler_min < Stopp_lightGrowing_minute){
        digitalWrite(lightGrowing, LOW);  //Ein
      }
      else {
        digitalWrite(lightGrowing, HIGH); //Aus
      }
    }
}

//------------------------------------------------------------------------------------------------------------------

//4.6. Ermittlung von EC- und pH-Wert

//Kalibrierung EC-Sonde
//TODO LINK
//!!!ACHTUNG!!!!! AUFRUF NUR WÄHREND DER KALIBRIERUNG!!!
//Kalibrierung des EC Wertes (Berechnung über Widerstandsmessung 1k Ohm)
void Calibrate (float Temperature_end, float Temperature_begin) {
//Kalbrierungshinweise 
Serial.println("Kalibrierung hat begonnen!");
Serial.println("Hinweis: Wurde der TDS-Wert des Messgeraetes angepasst?");
Serial.println("Bitte warten. Den Stecker und Temperaturfuehler dauerhaft bedeckt halten mit der Kalibrierfluessigkeit!");
sensors.requestTemperatures();                        //Aulesen der Wassertemp.
Temp_C = (sensors.getTempCByIndex(0) + offsetTempEC); //Temperaturberechnung 
Temp1_Value = Temp_C;
Temperature_begin=Temp_C;
//Kontrolle der Temperatur
Serial.print("Vergleichswert Temperatur 1 (in Grad Celcius): ");
Serial.println(Temp_C);
//Vergleich der Elektrodenspannung (Spannungsteiler)
Value = 0;
int i = 1;
while(i<=10){                   //Signal über Stecker leiten und Referenzwert messen 
digitalWrite(ECPower,HIGH);
A_to_D = analogRead(EC_Read);
A_to_D = analogRead(EC_Read);
digitalWrite(ECPower,LOW);
Value = Value + A_to_D;
i++;
delay(6000);                                          //Warten --> Messwerte könnten abweichen / nicht kleiner ! 
};
sensors.requestTemperatures();  
A_to_D=(Value/10);                                    //Mittelwert aus 10 Messungen bilden
Temp_C = (sensors.getTempCByIndex(0) + offsetTempEC); //Wassertemperatur + Offset
Temp1_Value = Temp_C;
Temperature_end=Temp_C;
//Kontrolle der Temperatur auf seriellen Oberfläche
Serial.print("Vergleichswerte Temperatur 2 (in Grad Celcius): ");
Serial.println(Temp_C);
//Berechnung des EC-Wertes und Spannungsfall 
EC =CalibrationEC*(1+(Temp_Coef*(Temperature_end-25.0)));
Vdrop= (((Vin)*(A_to_D))/1024.0);
//Widerstand vom Wasser
R_Water=(Vdrop*R1)/(Vin-Vdrop);       
//K-Faktor - Berechnung und Ausgabe des Ausgleichsfaktors für zukünftige Messung                      
float K_cal= 1000/(R_Water*EC);                            
Serial.print("Ersetze den Ausgleichsfaktor in der Konfigline / K_factor = ");
Serial.println(K_cal);
Serial.print("Temperaturdifferenz zwischen 2 Messungen = ");

//Differenz Berechnung beider gemessener Temperaturen mit einem Versatz von 6 Sekunden
float Temp_Diff=Temperature_end-Temperature_begin;
//Ausgabe der Temperaturdifferenz beider Messungen
Serial.print(Temp_Diff);
Serial.println(" (in Grad Celcius)");
Serial.println("Temperaturdifferenz darf maximal 0.15 abweichen. Wegen der Genauigkeit der Messung");
Serial.println("");
Calibrate ((float )Temperature_end, (float) Temperature_begin);
}

//Mittelwertbildung EC-Messwertes (Auswirkungen auf TDS-Berechnung)
const int arraySizeEC = 15;
float measuringEC[arraySizeEC] = {0};
float measureEC = 0;                    //gemessener EC-Wert
float averageEC = 0;                    //Mittelwert EC
float sumEC = 0;                        //Summe zur Ermittlung des Mittelwertes 

//Mittelwertbildung von EC- Messwertes
void average_calculation_EC(){
  measureEC = EC_at_25;
  for (int i = 0; i < arraySizeEC - 1; i++) {
    measuringEC[i] = measuringEC[i+1];
  }
  measuringEC[arraySizeEC - 1] = measureEC;
  // Berechnen Sie den Mittelwert aus allen Messungen
  sumEC= 0;
  for (int i = 0; i < arraySizeEC; i++) {
    sumEC += measuringEC[i];
  }
  averageEC = sumEC / arraySizeEC;
  return averageEC;
}

//Ermittlung - Electric Conductivity (=Elektrischer Leitwert / Einheit: mikroSiemens) --> über Widerstandsmessung
float copyLastValueTemp_C = 0;      //Fehlerminimierung - Vergleich auf plausiblen Wert des Wassertemp.sensors

void GetEC()
{
sensors.requestTemperatures();
Temp_C = sensors.getTempCByIndex(0) + offsetTempEC; //offset: Temperaturausgleich
if (Temp_C >= 0){
  copyLastValueTemp_C = Temp_C;
}
else{
  Temp_C = copyLastValueTemp_C;
}
Temperature = Temp_C;                               //Übergabe Temperatur für EC
digitalWrite(ECPower,HIGH);                         //5v in das Wasser leiten
A_to_D= analogRead(EC_Read);                        //Spannungsteiler auslesen
A_to_D= analogRead(EC_Read);                        //Spannungsteiler auslesen
digitalWrite(ECPower,LOW);                          //5V auf 0V setzen
Vdrop= (Vin*A_to_D) / 1024.0;                       //Berechnung der Spannungsdifferenz (Vergleich)
R_Water = (Vdrop*R1) / (Vin-Vdrop);                 //Berechnung Wasswiderstand
EC = 1000/ (R_Water*K_factor);                      //Berechnung des EC-Wertes in mS (Leitfähigkeit des Wassers)
EC_at_25 = (EC / (1+ Temp_Coef*(Temperature-25.0))) - offsetEC; //Referenz bei 25 Grad gewählt
ppm=(averageEC)*(PPM_Con*1000);                      //ausgerechneter TDS-Wert --> gelöste Konzentration an Salzprotonen
}
//----------------------------------------------------------------------------------------------------------------------------------------------------------------

//Ermittlung des PH-Wertes (Einheit: mol/liter)
//TODO link
int pHArray[ArrayLenthPH];                //Array zur Mittelwertbildung des PH-Wertes
int pHArrayIndex=0;
static float pHValue,voltage;             //Variablen für die PH-Berechnung und Angabe

void GetPH(){
      pHArray[pHArrayIndex++]=analogRead(SensorPin);
      if(pHArrayIndex==ArrayLenthPH)pHArrayIndex=0;
      voltage = avergearrayPH(pHArray, ArrayLenthPH)*5.0/1024;      //Referenzspannung in der Elektrode
      pHValue = 3.5*voltage+offsetPH;                               //Kompensation und PH-Faktor
      double avergearrayPH();                                       //Mittelwertbildung im Anschluss
}

//Mittelwertbildung des pH-Messwerten
double avergearrayPH(int* arr, int number){
  int i;
  int max,min;
  double avgPH;
  long amount=0;
  if(number<=0){
    Serial.println("Fehler bei Bildung des Mittelwertes!/n");
    return 0;
  }
  if(number<5){                 //kleiner als 5, errechnete direkte Statitiken
    for(i=0;i<number;i++){
      amount+=arr[i];
    }
    avgPH = amount/number;
    return avgPH;
  }else{
    if(arr[0]<arr[1]){
      min = arr[0];max=arr[1];
    }
    else{
      min=arr[1];max=arr[0];
    }
    for(i=2;i<number;i++){
      if(arr[i]<min){
        amount+=min;        //arr<min
        min=arr[i];
      }else {
        if(arr[i]>max){
          amount+=max;      //arr>max
          max=arr[i];
        }else{
          amount+=arr[i]; //min<=arr<=max
        }
      }
    }
    avgPH = (double)amount/(number-2);
  }
  return avgPH;
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------

//4.7. Umgebungssensoren für Technik- und NFT-Bereich

//Technikebene Temperatur und Feuchte über OneWire-Bus (-12B1)
float offsetTechTemp = 0.6;
float tempRoom1;              //Temperatur
float offsetTechHum = 2.5;
float humidityRoom1;          //Feuchte

void Temp_Hum_Tech(){
tempRoom1= dht1.readTemperature();              //Auslesen der Temp.
tempRoom1 = tempRoom1 + offsetTechTemp;         //Offsetberechnung Temp.
humidityRoom1 = dht1.readHumidity();            //Auslesen der Feuchte
humidityRoom1 = humidityRoom1 + offsetTechHum;  //Offsetberechnung Feuchte
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------

//NFT-Ebene 

//Temperatur-, Feuchte- und Luftqualitätsmessung (I2C / -16B1) 
//Wert für Berechnung und Übergabe
int CO2_read = 0;     //ausgelesener CO2 Wert
int CO2 = 0;          //Übergabe CO2 und Regelung
float TVOC;           //Reserve --> Schadstoffteilcen
float tempRoom2;      //Temperatur 
float humidityRoom2;  //Feuchte 

//Mittelwertbildung CO2
const int arraySizeCO2 = 20;          
float measuringCO2[arraySizeCO2] = {0};
float measureCO2 = 0;      //gemessener Wert von CO2
float offsetNftCO2 = 50;   //Offset CO2
float averageCO2 = 0;      //Mittelwert der CO2
float sumCO2 = 0;          //Summe der gesamten CO2-Werte

//Mittelwertbildung von CO2-Messwerten
void average_calculation_CO2(){
  for (int i = 0; i < arraySizeCO2 - 1; i++) {
    measuringCO2[i] = measuringCO2[i+1];
  }
  measuringCO2[arraySizeCO2 - 1] = measureCO2;
  // Berechnen Sie den Mittelwert aus allen Messungen
  sumCO2= 0;
  for (int i = 0; i < arraySizeCO2; i++) {
    sumCO2 += measuringCO2[i];                //Summe aus allen CO2-Werten
  }
  averageCO2 = (sumCO2 / arraySizeCO2)+offsetNftCO2;
  return averageCO2;
}

//Rechte NFT-Ebene - Temperatur und Feuchte über I2C (-16B1)
float offsetNftTempR = -3.6;    //Temperatur
float offsetNftMoistR = 2.5;    //Feuchte

//Luftqualität der rechten Seite des NFT-Bereiches ermitteln
void airQuality(){
ccs.available();            //Verfügbarkeit des CSS811-Sensors überprüfen
ccs.readData();             //CSS811-Sensor auslesen
TVOC =ccs.getTVOC();        //TVOC-Wert übergeben
tempRoom2 = hdc1080.readTemperature() + offsetNftTempR;   //Offsetberechnung Temperatur
humidityRoom2 =hdc1080.readHumidity() + offsetNftMoistR;  //Offsetberechnung Feuchte
CO2_read  = ccs.geteCO2();  //Übergabe es ausgelesenen CO2-Wert  
measureCO2 = CO2_read;      
average_calculation_CO2();  //Mittelwertbildung
CO2 = averageCO2;           //Übergabe des Mittelwertes in vorgesehen Variable
}

//Linke NFT-Ebene -Temperatur und Feuchte über OneWire-Bus im linken NFT-Bereich (-17B1)
float tempRoom3;              //Temperatur
float offsetNftTempL = 0.7;
float humidityRoom3;          //Feuchte
float offsetNftMoistL = 1.8;

//Luftqualität der linken Seite des NFT-Bereiches ermitteln
void Temp_Hum_NFT(){
tempRoom3= dht2.readTemperature() + offsetNftTempL;             //Offsetberechnung Temperatur (links) mit Übergabe
humidityRoom3 = dht2.readHumidity() + offsetNftMoistL;          //Offsetberechnung Feuchte (links) mit Übergabe
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------

//4.8. Intervallsteuerung der Zirkulationspumpe und Dosierung

//Hauptpumpe NFT

//Verhältnis von Ein- und Ausschaltzeit beträgt 2:1

int minTimeNFT=2;                         //einstellbare Mindestzeit (nicht kleiner als 2 Minuten!)
int adjustableTimeNFT = iPumpOn;          //Einstellbare Zeit über Display
int NFTEinschaltzeit = 0;                 //Einschaltzeit der einzelnen Fälle in der CASE-Struktur
//Flankeauswertung wenn jeweilige Zeit über Modulo verglichen
int countNFT = 1;                         //Anfang der CASE-Struktur
int stateNFT = LOW;                       //Status der NFT-Pumpe
int laststateNFT = LOW;                   //gespeicherter des letzten Ansteuerungstatus

//Ermittlung der Intervallzeit über das 2:1 Verhältnis und Vergleich der Mindestzeit
void pumpTimeControlNFT(){
  for (int i=1; i<61;i++){
    if (iPumpOn <= minTimeNFT){                         //wenn eingestellt Zeit kleiner als Mindestzeit 
      NFTEinschaltzeit = minTimeNFT/2;                  //übernehme Mindestzeit
    } 
    else if (iPumpOn==i){//(adjustableTimeNFT==i){      //wenn eingestellte Zeit zwischen 1 und 60 
      NFTEinschaltzeit = (iPumpOn)/2;                   //übernehme Display Sollwert durch 2
    }
  }
}

//Intervallansteuerung der Zirkulationpumpe
void NFTPumpOn(){
  pumpTimeControlNFT();                         //Auswertung der Einschaltzeit
  if (zaehler_min % (NFTEinschaltzeit) == 0){   //wenn eingestellt Einschaltzeit erreicht --> NFT-Pumpe EIN 
    stateNFT = HIGH;
  }
  else{                                         //sonst Pumpe AUS
    stateNFT=LOW;
  }
  //Flankenwechsel erkennen
  if(laststateNFT == LOW && stateNFT == HIGH) {
    //Abhängig vom Counter wird passender Fall aufgerufen
    switch(countNFT) {
      case 1: digitalWrite(pumpNFT,LOW);  //Pumpe EIN
              pumpNFTstatus=true;
              break;
      case 2: digitalWrite(pumpNFT,LOW);  //Pumpe EIN
              pumpNFTstatus=true;
              break;
      case 3: digitalWrite(pumpNFT,HIGH); //Pumpe AUS
              pumpNFTstatus=false;        
              break;            
      }   
    countNFT++;                           //Counter um 1 erhöhen
    if(countNFT == 4) {                   //wenn Counter 4 --> zurücksetzen auf 1
      countNFT = 1;         
    }
  }
laststateNFT = stateNFT;                  //Speicherung des letzten Zustands
return NFTEinschaltzeit;
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------

//Dosierung pH-Lösung
int waitMinDosagePH=20;                           //Wartezeit bis zur nächsten Dosierung in Minuten
int proportionFixPH = waitMinDosagePH * 30;       //Wartezeit wird mit Faktor 30 Multipliziert (eigene Zeiteinheit)
                                                  //Für die Anzeige auf dem Display --> Berechnung der Proportionalen Zeitsteuerung --> Wartezeit = proportionFix * adjustableTimePH
                                                  //proportionFixPH = Wartezeit / AdjustableTimePH --> = (60s) / 2 = 30 (ERGEBNIS) --> pro Minute einen Faktor um 30 erhöhen
int proportionPH = proportionFixPH;               //Verhältnis der Dosierung zu Warte zeit 1 / Proportion --> BSP.: 1 / 60 --> umso länger ich Dosiere umso länger wartet man !!!!

//Dauer der Dosierung
int minTimePH=2;                                //Mindestzeit in Minuten 
int adjustableTimePH = 2;                       //einstellbare Dosierdauer in Sekunden (nicht kleiner als 2 s !)
int PHEinschaltzeit=0;                          //Einschaltzeit der pH-Dosierung

//Flankeauswertung wenn jeweilige Zeit über Modulo verglichen
int countPH = 1;              //Zähler für die CASE-Struktur
int statePH = LOW;            //Status de der pH-Dosierung
int laststatePH = LOW;        //letzter Status der pH-Dosierung

//Ermittlung der Intervallzeit zur nächsten Dosierung und Vergleich der Mindestzeit 
void dosingpumpTimePH(){
  for (int i=1; i<61;i++){
    if (adjustableTimePH < minTimePH){          //wenn eingestellt Zeit kleiner als Mindestzeit 
      PHEinschaltzeit = minTimePH;              //übernehme Mindestzeit
    } 
    else if (adjustableTimePH==i){              //wenn eingestellte Zeit zwischen 1 und 60
      PHEinschaltzeit = adjustableTimePH;       //übernehme eingestellte Zeit 
    }
  }
}

//Intervallansteuerung der pH-Dosierungspumpe
void PHPumpOn(){ 
dosingpumpTimePH();                             //Auswertung der Einschaltzeit
if (zaehler_sek % (PHEinschaltzeit) == 0){      //wenn eingestellt Einschaltzeit erreicht --> pH-Dosierungspumpe EIN  
  statePH = HIGH;
}
else{                                           //sonst pH-Dosierungspumpe AUS
  statePH=LOW;
}
 //Flankenwechsel erkennen
 if(laststatePH == LOW && statePH == HIGH) {
    switch(countPH) {
     case 1:    digitalWrite(pumpPH,LOW);     //Pumpe EIN
                break; 
    default:    digitalWrite(pumpPH,HIGH);    //Pumpe AUS
                break;

    }   
    countPH++;                        //Zähler erhöhen
    if(countPH == proportionPH) {     //wenn zähler Proportionsfakotr erreicht Zähler zurücksetzen
    countPH = 1;
    }
 }
  laststatePH = statePH;             //letzter Status der pH-Dosieransteuerung
}

//Sperre der Dosierung (erst PH dann EC-Wert korrigieren)
//Merker um die EC-Dosierung zu blockieren bis der PH-Wert erreicht ist
bool PHDosageOn = false;

//Dosierung EC-Lösung
int waitMinDosageEC=20;                         //Wartezeit in Minuten zum Nachdosieren
int proportionFixEC=waitMinDosageEC * 30;       //Wartezeit wird mit Faktor 30 Multipliziert (eigene Zeiteinheit)
                                                //Für die Anzeige auf dem Display --> Berechnung der Proportionalen Zeitsteuerung --> Wartezeit = proportionFix * adjustableTimePH
                                                //proportionFixPH = Wartezeit / AdjustableTimePH --> = (60s) / 2 = 30 (ERGEBNIS) --> pro Minute einen Faktor um 30 erhöhen
int proportionEC = proportionFixEC +1;          //Verhältnis der Dosierung zu Warte zeit 1 / Proportion --> BSP.: 1 / 60 --> umso länger ich Dosiere umso länger wartet man !
int minTimeEC=2;                                //Mindestzeit in Minuten (darf nicht kleiner als 2 s sein)
int adjustableTimeEC = 2;                       //einstellbare Intervallzeit der Ansteuerung von EC-Dosierung 
int ECEinschaltzeit=0;                          //Einschaltzeit der Dosierung
int countEC = 1;                                //Zähler für die CASE-Struktur
int stateEC = LOW;                              //Status der Ansteuerung von EC-Dosierung
int laststateEC = LOW;                          //letzter Status der Ansteuerung von EC-Dosierung

//Ermittlung der Intervallzeit zur nächsten Dosierung und Vergleich der Mindestzeit 
void dosingpumpTimeEC(){
  for (int i=1; i<61;i++){                //wenn eingestellt Zeit kleiner als Mindestzeit
  if (adjustableTimeEC < minTimeEC){      //Übernehme Mindestzeit
    ECEinschaltzeit = minTimeEC;
  } 
  else if (adjustableTimeEC==i){          //wenn eingestellte Zeit zwischen 1 und 60
    ECEinschaltzeit = adjustableTimeEC;   //Übernehme eingestellte Zeit 
    }
  
  }
}

//Intervallansteuerung der pH-Dosierungspumpe
void ECPumpOn(){
dosingpumpTimeEC();                                             //Auswertung der Einschaltzeit
if (zaehler_sek % (ECEinschaltzeit) == 0 && averageEC> 0.1){    //wenn eingestellt Einschaltzeit erreicht --> pH-Dosierungspumpe EIN und Grenzwert Freigabe der Dosierung auf "0.1" da der Wert erst stabild sein muss
  stateEC = HIGH;
}
else{                                                           //sonst pH-Dosierungspumpe AUS
  stateEC=LOW;
}
 //Flankenwechsel erkennen
 if(laststateEC == LOW && stateEC == HIGH) {
    switch(countEC) {
     case 1:    digitalWrite(pumpEC,LOW);       //Pumpe EIN
                break; 
    default:    digitalWrite(pumpEC,HIGH);      //Pumpe AUS
                break; 
    }   
    countEC++;    //zähler erhöhen
    if(countEC == proportionEC) {               //zähler zurücksetzen, wenn eingestellt Porportion erreicht ist
    countEC = 1;
    }
 }
  laststateEC = stateEC;  //letzter Status der pH-Dosieransteuerung
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//4.9. Belüftung
//Variablen der Funktion
float Average_Temp_System;        //Durchschnittstemperatur im NFT-Bereich
float Average_Moist_System;       //Durchschnittsfeuchte im NFT-Bereich

//Hystereswerte für Lüftungansteuerung (Grenzwersteuerung Parameter)
float Hysteresis_Temp_System = 1.5;     //Hysterese Temperatur
float Hysteresis_Moist_System = 7.5;    //Hysterese Feuchte 
float Hysteresis_CO2_System = 200.0;    //Hysterese CO2

//Grenzwertregelung des Belüftung
void Lueftung(){
  //wenn eingestellte Sollwert von Temperatur, Feuchte, CO2 mit jeweilig angegebener Hysterese überschritten werden --> Ablüfter EIN
  if(  (Average_Temp_System >= (flSollPlantTemp + Hysteresis_Temp_System))   ||    (Average_Moist_System >= (flSollPlantMois + Hysteresis_Moist_System))  ||    (CO2 >= (flSollCO2 + Hysteresis_CO2_System))    ){
    digitalWrite(ventilator, LOW);  //Ablüfter EIN
  }
  //wenn eingestellte Sollwert von Temperatur, Feuchte, CO2 mit jeweilig angegebener Hysterese unterschritten werden --> Ablüfter EIN
  else if(  (Average_Temp_System < (flSollPlantTemp - Hysteresis_Temp_System))  &&   (Average_Moist_System < (flSollPlantMois - Hysteresis_Moist_System))   &&    (CO2 < (flSollCO2 - Hysteresis_CO2_System))  ){
    digitalWrite(ventilator, HIGH); //Ablüfter AUS
  }
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//5. Visualisierung und Zuweisungen auf dem NEXTION- Display

//Variablen

//Uhrzeit
String Uhrzeit = "";      //Darstellung Uhrzeit

//Integer
//Uhrzeit
int iTimeH = 0;       //aktuelle Uhrzeit Stunden 0-23
int iTimeM = 0;       //aktuelle Uhrzeit Minuten 0-59

//Texte
//Sollwert Temperatur, Feuchte und CO2 im NFT-Bereich
String stSollPlantTemp;   //Grenzwert Temperatur Pflanzen
String stSollPlantMois;   //Grenzwert Feuchte Pflanzen
String stSollCO2;         //Grenzwert CO2

//Sollwert Dosierung
String stSollPH;  //Grenzwert PH
String stSollEC;  //Grenzwert EC

//Übergabe Messwerte 
//Mittelwert NFT-Bereich
String stIstPlantTemp;  //Istwert Temperatur Pflanzen
String stIstPlantMois;  //Istwert Feuchte Pflanzen
String stIstCO2;        //Istwert CO2

//Dosierung
String stIstPH;     //Istwert PH
String stIstEC;     //Istwert EC
String stTDS;       //Istwert TDS
String stWatertemp; //Istwert Wassertemperatur

//Technik Umgebungssensoren
String stBotTemp;     //Istwert Temperatur Technik
String stBotMois;     //Istwert Feuchte Technik

//Volumen
String stTanklevel;  //Istwert Volumenmessung Tank

//Intervallsteuerung NFT-Pumpe
String stPumpOff;   //Einschaltzeit NFT-Pumpe

//Funktionen für Displayaktionen

//Uhrzeit speichern
void trigger0(){  
  iTimeH = myNex.readNumber("Settings.iSetTimeH.val");
  iTimeM = myNex.readNumber("Settings.iSetTimeM.val");
  zaehler_min = iTimeM;
  zaehler_hour = iTimeH;
}

//Hand Anlage Ein/Aus
void trigger1(){  
  if (myNex.readNumber("Manual.swAnlage.val") == 1){    //wenn Schalter EIN
    ANLAGE = 1;           //Anlagefreigabe AUTOMATIK
  }
  else{
    ANLAGE = 0;           //Anlagenfreigabe HAND
    trigger5();           //Aktualisierung Freigabe Dosierung
  }
EEPROM.put(100, ANLAGE);  //Speicherung im EEPROM
}

//Hand Anzucht-Beleuchtung
void trigger2(){  
if (ANLAGE == 0){                                       //wenn Anlagenschalter auf Hand
  if (myNex.readNumber("Manual.swLight20.val") == 1){   //wenn Schalter EIN
    digitalWrite(lightGrowing, LOW);      //Zirkulationspumpe EIN
  }
  else digitalWrite(lightGrowing, HIGH);  //Zirkulationspumpe AUS
  }
}

//Hand NFT-Beleuchtung
void trigger3(){  
if (ANLAGE == 0){                                                     //wenn Anlagenschalter auf Hand
  if (myNex.readNumber("Manual.swLight40.val") == 1 && ANLAGE == 0){  //wenn Schalter EIN und Anlage auf Hand
    digitalWrite(lightNFT, LOW);        //Beleuchtung EIN
  }
  else digitalWrite(lightNFT, HIGH);    //Beleuchtung AUS
  }
}

//Hand Belüftung
void trigger4(){  
if (ANLAGE == 0){                                   //wenn Anlagenschalter auf Hand
  if (myNex.readNumber("Manual.swVent.val") == 1){  //wenn Schalter EIN
    digitalWrite(ventilator, LOW);      //Belüftung EIN
  }
  else digitalWrite(ventilator, HIGH);  //Belüftung AUS
  }
}

//Hand Freigabe Dosierung
void trigger5(){  
  if (myNex.readNumber("Manual_2.swDos.val") == 1 && ANLAGE == 1){  //wenn Schalter EIN und Anlage auf Automatik
    DOSIERUNG = 1;        //Dosierungfreigabe EIN
    trigger6();           //Aktualisierung von Hand PH-Dosierung
    trigger7();           //Aktualisierung von Hand EC-Dosierung
  }
  else DOSIERUNG = 0;         //sonst Dosierungsfreigabe AUS
  EEPROM.put(110, DOSIERUNG); //Speicherung im EEPROM
}

//Hand PH-Dosierung TODO
void trigger6(){  
  if (myNex.readNumber("Manual_2.swPH.val") == 1 && digitalRead(pumpNFT) == LOW && DOSIERUNG == 0){ //wenn Schalter EIN & Zirkulationspumpe EIN & Dosierungsfreigabe AUS
    digitalWrite(pumpPH, LOW);        //Dosierpumpe PH EIN
  }
  else digitalWrite(pumpPH, HIGH);    //Dosierpumpe PH AUS
}

//Hand Dünger-Dosierung
void trigger7(){  
  if (myNex.readNumber("Manual_2.swDung.val") == 1 && digitalRead(pumpNFT) == LOW && DOSIERUNG == 0){ //wenn Schalter EIN & Zirkulationspumpe EIN & Dosierungsfreigabe AUS
    digitalWrite(pumpEC, LOW);        //Dosierungpumpe EC  EIN
  }
  else digitalWrite(pumpEC, HIGH);    //Dosierungpumpe EC  AUS
}

//Hand Pumpe Haupttank
void trigger8(){  
if (ANLAGE == 0){                                     //wenn Anlagenfreigabe Hand   
  if (myNex.readNumber("Manual_2.swPump.val") == 1){  //wenn Schalter EIN
    digitalWrite(pumpNFT, LOW);         //Zirkulationspumpen EIN
  }
  else {
    digitalWrite(pumpNFT, HIGH);        //Zirkulationspumpe AUS
    trigger6();                         //Akutalisierung von Hand PH-Dosierung
    trigger7();                         //Akutalisierung von Hand EC-Dosierung
  }
}
}

//Zeitsteuerung NFT-Beleuchtung
void trigger9(){  
  Start_lightNFT_hour = myNex.readNumber("Times40.iLight40FH.val");       //Übergabe der EIN- und Ausschaltzeiten
  Start_lightNFT_minute = myNex.readNumber("Times40.iLight40FM.val");
  Stopp_lightNFT_hour = myNex.readNumber("Times40.iLight40TH.val");
  Stopp_lightNFT_minute = myNex.readNumber("Times40.iLight40TM.val");
  EEPROM.put(0, Start_lightNFT_hour);                                     //Speicherung im EEPROM
  EEPROM.put(5, Start_lightNFT_minute);
  EEPROM.put(10, Stopp_lightNFT_hour);
  EEPROM.put(15, Stopp_lightNFT_minute);
}

//Zeitsteuerung Pumpe
void trigger10(){   
  iPumpOn = myNex.readNumber("TimesPump.iPumpOn.val");    //Übergabe Einschaltzeit
  EEPROM.put(20, iPumpOn);                                //Speicherung EEPROM
}

void trigger11(){   //Zeitsteuerung Anzucht-Beleuchtung
  Start_lightGrowing_hour = myNex.readNumber("Times20.iLight20FH.val");     //Übergabe der EIN- und Ausschaltzeiten
  Start_lightGrowing_minute = myNex.readNumber("Times20.iLight20FM.val");
  Stopp_lightGrowing_hour = myNex.readNumber("Times20.iLight20TH.val");
  Stopp_lightGrowing_minute = myNex.readNumber("Times20.iLight20TM.val");
  EEPROM.put(25, Start_lightGrowing_hour);                                  //Speicherung im EEPROM
  EEPROM.put(30, Start_lightGrowing_minute);
  EEPROM.put(35, Stopp_lightGrowing_hour);
  EEPROM.put(40, Stopp_lightGrowing_minute);
}

//Sollwert Temperatur Pflanzen
void trigger12(){  
stSollPlantTemp = myNex.readStr("PlantTemp.tSollPlantTemp.txt");    //Übergabe Sollwert
flSollPlantTemp = stSollPlantTemp.toFloat();                        //Umwandlung in float
EEPROM.put(45, flSollPlantTemp);                                    //Speicherung im EEPROM
}

//Sollwert Feuchte Pflanzen
void trigger13(){   
stSollPlantMois = myNex.readStr("PlantMoisture.tSollPlantMois.txt");  //Übergabe Sollwert
flSollPlantMois = stSollPlantMois.toFloat();                          //Umwandlung in float
EEPROM.put(50, flSollPlantMois);                                      //Speicherung im EEPROM
}

//Sollwert CO²
void trigger14(){ 
stSollCO2 = myNex.readStr("CO2.tSollCO2.txt");                        //Übergabe Sollwert
flSollCO2 = stSollCO2.toFloat();                                      //Umwandlung in float
EEPROM.put(55, flSollCO2);                                            //Speicherung im EEPROM
}

//Sollwert PH
void trigger15(){   
stSollPH = myNex.readStr("PH.tSollPH.txt");   //Übergabe Sollwert
flSollPH = stSollPH.toFloat();                //Umwandlung in float
EEPROM.put(60, flSollPH);                     //Speicherung im EEPROM
}

//Sollwert EC
void trigger16(){   
stSollEC = myNex.readStr("EC.tSollEC.txt");   //Übergabe Sollwert
flSollEC = stSollEC.toFloat();                //Umwandlung in float
EEPROM.put(75, flSollEC);                     //Speicherung im EEPROM
}

//Einlesen der Schalter-Zustände / Handbetrieb Seite 1
void trigger17(){   
myNex.writeNum("Manual.swAnlage.val", ANLAGE);                          //Aktualisierung Anlageschalter
myNex.writeNum("Manual.swLight20.val", !(digitalRead(lightGrowing)));   //Akutalisierung Aktorenansteuerung Seite 1
myNex.writeNum("Manual.swLight40.val", !(digitalRead(lightNFT)));
myNex.writeNum("Manual.swVent.val", !(digitalRead(ventilator)));
}

//Einlesen der Schalter-Zustände / Handbetrieb Seite 2
void trigger18(){   
myNex.writeNum("Manual_2.swDos.val", DOSIERUNG);                        //Aktualisierung Freigabe Dosierung        
myNex.writeNum("Manual_2.swPH.val", !(digitalRead(pumpPH)));            //Akutalisierung Aktorenansteuerung Seite 2
myNex.writeNum("Manual_2.swDung.val", !(digitalRead(pumpEC)));
myNex.writeNum("Manual_2.swPump.val", !(digitalRead(pumpNFT)));
}

//Standby-Zeit speichern
void trigger19(){   
  iStandby = myNex.readNumber("Settings.iStandby.val");     //Übergabe Standbyzeit in Sekunden
  EEPROM.put(70, iStandby);                                 //Speicherung im EEPROM
}

//Quittieren Button
void trigger20(){   
  Reset_Leakage = 1;    //Übergabe an Resetbefehl
}

//Refresh Home
void trigger21(){
if(iTimeM >= 10 && iTimeH >=10){                    //wenn Zeit größer gleich 10 (MINUTEN und STUNDEN)
Uhrzeit = String(iTimeH) + ":" + String(iTimeM);    //Layout Zeitanzeige ohne hinzugefügter 0
}
else if (iTimeM < 10 && iTimeH < 10){                           //wenn Zeit kleiner 10 (MINUTEN und STUNDEN)  
Uhrzeit = "0" + String(iTimeH) + ":" + "0" + String(iTimeM);    //Layout Zeitanzeige mit hinzugefügter 0
}
else if (iTimeM < 10){                                          //wenn nur Minuten kleiner 10
  Uhrzeit = String(iTimeH) + ":" + "0" + String(iTimeM);
}
else if (iTimeH < 10){                                          //wenn nur Stunden kleiner 10
  Uhrzeit = "0" + String(iTimeH) + ":" + String(iTimeM);
}
myNex.writeStr("Home.tUhrzeit.txt", Uhrzeit);                   //Akutalisierung Uhrzeit
myNex.writeNum("Home.bIndicator.pic", Pic_Indicator);           //Aktualisierung Störungsanzeige 
}

//Refresh Meldeliste 
void trigger22(){
myNex.writeNum("Indicator.pLeckage.pic", Pic_Leckage);
myNex.writeNum("Indicator.pPlantSensL.pic", Pic_PlantSensL);
myNex.writeNum("Indicator.pPlantSensR.pic", Pic_PlantSensR);
myNex.writeNum("Indicator.pBotSens.pic", Pic_BotSens);
}

//Refresh Zeiten Pumpe
void trigger23(){
stPumpOff = String (NFTEinschaltzeit);                //Einschaltzeit NFT-Pumpe
myNex.writeStr("TimesPump.tPumpOff.txt", stPumpOff);  //Übertragen der Einschaltzeit
}

//Refresh Temperatur Pflanzen
void trigger24(){
stIstPlantTemp = String(Average_Temp_System);                   //Istwert Temperatur Pflanzen
myNex.writeStr("PlantTemp.tIstPlantTemp.txt", stIstPlantTemp);  //Übertragen der Temperatur
}

//Refresh Feuchte Pflanzen
void trigger25(){
stIstPlantMois = String(Average_Moist_System);                      //Istwert Feuchte Pflanzen
myNex.writeStr("PlantMoisture.tIstPlantMois.txt", stIstPlantMois);  //Übertragen der Feuchte
}

//Refresh CO2
void trigger26(){
stIstCO2 = String(CO2);                           //Istwert CO2 Pflanzen
myNex.writeStr("CO2.tIstCO2.txt", stIstCO2);      //Übertragen der Feuchte
}

//Refresh Luft Technik
void trigger27(){
stBotTemp = String(tempRoom1);//Pascal                  //Temperatur Technik
stBotMois = String(humidityRoom1);//Pascal              //Feuchte Technik
myNex.writeStr("BotTemp.tBotTemp.txt", stBotTemp);      //Übertragen der Temperatur
myNex.writeStr("BotTemp.tBotMois.txt", stBotMois);      //Übertragen der Feuchte
}

//Refresh PH
void trigger28(){
stIstPH = String(pHValue);//Pascal                      //Istwert PH
myNex.writeStr("PH.tIstPH.txt", stIstPH);               //Übertragen des PH-Wertes
}

//Refresh EC
void trigger29(){
stIstEC = String(averageEC);//Pascal                    //Istwert EC
myNex.writeStr("EC.tIstEC.txt", stIstEC);               //Übertragung EC-Wert
}

//Refresh TDS
void trigger30(){
stTDS = String(ppm);                                //Istwert TDS
stWatertemp = String(Temp_C);                       //Istwert Wassertemperatur
myNex.writeStr("TDS.tTDSppm.txt", stTDS);           //Übertragung TDS-Wert
myNex.writeStr("TDS.tWatertemp.txt", stWatertemp);  //Übertragung Wassertemp.
}

//Refresh Tanklevel
void trigger31(){
stTanklevel = String(averageWaterlevel);//Pascal          //Istwert Volumen Tank
myNex.writeStr("Tanklevel.tTanklevel.txt", stTanklevel);  //Übertragung Volumen in Liter
}

//Refresh Meldeliste_2
void trigger32(){
myNex.writeNum("Indicator_2.pEC.pic", Pic_EC);                  //Aktualisierung der Störungsmeldungen zur Anzeige auf dem Display
myNex.writeNum("Indicator_2.pPH.pic", Pic_PH);
myNex.writeNum("Indicator_2.pWatertemp.pic", Pic_Watertemp);
myNex.writeNum("Indicator_2.pWaterlevel.pic", Pic_Waterlevel);
}

//Akustischen Alarm aktivieren
void SetAlarm(){
  myNex.writeNum("Home.wav0.en", 1);
  myNex.writeNum("Settings.wav0.en", 1);
  myNex.writeNum("Indicator.wav0.en", 1);
  myNex.writeNum("Indicator_2.wav0.en", 1);
  myNex.writeNum("Menu.wav0.en", 1);
  myNex.writeNum("Manual.wav0.en", 1);
  myNex.writeNum("Manual_2.wav0.en", 1);
  myNex.writeNum("Times40.wav0.en", 1);
  myNex.writeNum("Times20.wav0.en", 1);
  myNex.writeNum("TimesPump.wav0.en", 1);
  myNex.writeNum("PlantTemp.wav0.en", 1);
  myNex.writeNum("PlantMoisture.wav0.en", 1);
  myNex.writeNum("CO2.wav0.en", 1);
  myNex.writeNum("BotTemp.wav0.en", 1);
  myNex.writeNum("PH.wav0.en", 1);
  myNex.writeNum("EC.wav0.en", 1);
  myNex.writeNum("TDS.wav0.en", 1);
  myNex.writeNum("Tanklevel.wav0.en", 1);
}

//Akustischen Alarm zurücksetzen
void QuitAlarm(){
  myNex.writeNum("Home.wav0.en", 0);
  myNex.writeNum("Settings.wav0.en", 0);
  myNex.writeNum("Indicator.wav0.en", 0);
  myNex.writeNum("Indicator_2.wav0.en", 0);
  myNex.writeNum("Menu.wav0.en", 0);
  myNex.writeNum("Manual.wav0.en", 0);
  myNex.writeNum("Manual_2.wav0.en", 0);
  myNex.writeNum("Times40.wav0.en", 0);
  myNex.writeNum("Times20.wav0.en", 0);
  myNex.writeNum("TimesPump.wav0.en", 0);
  myNex.writeNum("PlantTemp.wav0.en", 0);
  myNex.writeNum("PlantMoisture.wav0.en", 0);
  myNex.writeNum("CO2.wav0.en", 0);
  myNex.writeNum("BotTemp.wav0.en", 0);
  myNex.writeNum("PH.wav0.en", 0);
  myNex.writeNum("EC.wav0.en", 0);
  myNex.writeNum("TDS.wav0.en", 0);
  myNex.writeNum("Tanklevel.wav0.en", 0);
}


//Voreingestellt Werte während des Betriebs wieder initialisieren
void getfromEEPROM(){
Start_lightNFT_hour = EEPROM.get(0, Start_lightNFT_hour);
Start_lightNFT_minute = EEPROM.get(5, Start_lightNFT_minute);
Stopp_lightNFT_hour = EEPROM.get(10, Stopp_lightNFT_hour);
Stopp_lightNFT_minute = EEPROM.get(15, Stopp_lightNFT_minute);
iPumpOn = EEPROM.get(20, iPumpOn);
Start_lightGrowing_hour = EEPROM.get(25, Start_lightGrowing_hour);
Start_lightGrowing_minute = EEPROM.get(30, Start_lightGrowing_minute);
Stopp_lightGrowing_hour = EEPROM.get(35, Stopp_lightGrowing_hour);
Stopp_lightGrowing_minute = EEPROM.get(40, Stopp_lightGrowing_minute);
flSollPlantTemp = EEPROM.get(45, flSollPlantTemp);    
flSollPlantMois = EEPROM.get(50, flSollPlantMois); 
flSollCO2 = EEPROM.get(55, flSollCO2); 
flSollPH = EEPROM.get(60,flSollPH);   
iStandby = EEPROM.get(70, iStandby);
flSollEC = EEPROM.get(75, flSollEC);  
ANLAGE = EEPROM.get(100, ANLAGE); 
DOSIERUNG = EEPROM.get(110, DOSIERUNG);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//6. Ausgabe von Alarm- und Störmeldungen & RUN-LED

//RUN-LED - Überprüfung ob Programm abgearbeitet wird
bool hilfsmerkerLED;

void test_LED(){
  //Test LED
  hilfsmerkerLED =! hilfsmerkerLED;
  //Display
  digitalWrite(LED,hilfsmerkerLED);
}

//Funktionen Alarme
//Alarm 1
void Funktion_Alarm_PlantSensL(){
  //Alarm taucht auf
  if(tempRoom3 >= GW_PlantTempL_max || tempRoom3 <= GW_PlantTempL_min || humidityRoom3 >= GW_PlantMoistL_max || humidityRoom3 <= GW_PlantMoistL_min || isnan(tempRoom3) || isnan(humidityRoom3) || tempRoom3<=0 || humidityRoom3<=0){
  	Pic_PlantSensL = 10;    //Zustand: Störung anzeigen
  }
  else{
	Pic_PlantSensL = 9;       //Zustand: OK anzeigen
  }
}

//Alarm 2
void Funktion_Alarm_PlantSensR(){
  //Alarm taucht auf
  if(tempRoom2 >= GW_PlantTempR_max || tempRoom2 <= GW_PlantTempR_min || humidityRoom2 >= GW_PlantMoistR_max || humidityRoom2 <= GW_PlantMoistR_min || CO2_read >= GW_PlantCO2R_max || CO2_read <= GW_PlantCO2R_min || tempRoom2<= 0 || humidityRoom2<= 0 || CO2_read <= 0 || isnan(tempRoom2) || isnan(humidityRoom2) || isnan(CO2_read)){
  	Pic_PlantSensR = 10;    //Zustand: Störung anzeigen
  }
  else{
	Pic_PlantSensR = 9;       //Zustand: OK anzeigen
  }
}

//Alarm 3
void Funktion_Alarm_BotSens(){
  //Alarm taucht auf
  if(tempRoom1 >= GW_BotTemp_max || tempRoom1 <= GW_BotTemp_min || humidityRoom1 >= GW_BotMoist_max || humidityRoom1 <= GW_BotMoist_min){   
  	Pic_BotSens = 10;       //Zustand: Störung anzeigen
  }
  else{
	Pic_BotSens = 9;          //Zustand: OK anzeigen
  }
}


//Alarm 4
bool failureMeasurementsPH = false;

void Funktion_Alarm_PH_Value(){
  //Alarm taucht auf
  if(pHValue >= GW_PH_Value_max || pHValue <= GW_PH_Value_min){
  	Pic_PH = 10;                        //Zustand: Störung anzeigen
    failureMeasurementsPH = true;       //Hilfsmerker der Störung von PH-Messung (aktiv)
  }
  else{
	  Pic_PH = 9;                         //Zustand: OK anzeigen
    failureMeasurementsPH = false;      //Hilfsmerker der Störung von PH-Messung (nicht aktiv)
  }
}

//Alarm 5
//Störungen - Hilfsmerker für EC-Messung
int failureWatertemp = 0;             //Hilfsmerker1 Wassertemperatur
bool failureMeasurementsEC = false;   //Hilfsmerker2 EC-Messung

void Funktion_Alarm_EC_Value(){
  //Alarm taucht auf
  if(EC_at_25 >= GW_EC_Value_max || EC_at_25 <= GW_EC_Value_min || failureWatertemp ==1){
  	Pic_EC = 10;                    //Zustand: Störung anzeigen
    failureMeasurementsEC = true;   //Hilfsmerker der Störung von EC-Messung (aktiv)
  }
  else{
	  Pic_EC = 9;                     //Zustand: OK anzeigen
    failureMeasurementsEC = false;  //Hilfsmerker der Störung von EC-Messung (nicht aktiv)
  }
}

//Alarm 6
void Funktion_Alarm_Wassertemp(){
  //Alarm taucht auf
  if((Temp_C >= GW_Watertemp_max || Temp_C <= GW_Watertemp_min || isnan(Temp_C)) && !(Temp_C == -127.30)){
  	Pic_Watertemp = 10;         //Zustand: Störung anzeigen
    failureWatertemp = 1;       //Hilfsmerker der Störung von Wassertemp. (aktiv)
  }
  else{
	Pic_Watertemp = 9;            //Zustand: OK anzeigen
  failureWatertemp = 0;         //Hilfsmerker der Störung von Wassertemp. (nicht aktiv)
  }
}

//Alarm 7
void Funktion_Alarm_Wasserlevel(){
  //Alarm taucht auf
  if(volume_tank_cal >= GW_Waterlevel_max || volume_tank_cal <= GW_Waterlevel_min || volume_tank_cal <= 0 || distance <0 || distance >=50){
  	Pic_Waterlevel = 10;      //Zustand: Störung anzeigen
  }
  else{
	Pic_Waterlevel = 9;         //Zustand: OK anzeigen
  }
}

//Alarm 8 - Sammelstörung aller Störmeldungen
void Sammelstoerung(){
  if(Pic_Leckage == 10 || Pic_PlantSensL == 10 || Pic_PlantSensR == 10 || Pic_BotSens == 10 || Pic_PH == 10 || Pic_EC == 10|| Pic_Watertemp == 10 || Pic_Waterlevel == 10){
    Pic_Indicator = 8;        //Zustand: Störung anzeigen
  }
  else{
    Pic_Indicator = 7;        //Zustand: OK anzeigen
  }
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//7. Intervallzeitsteuerungen und -abfragen der Sensoren

//Event 1 alle 5 Sekunden (EC-Messung + Mittelwertbildung)
const unsigned long eventInterval1 = 5 * 1000UL;            //alle 5 Sekunden soll ein Event durchgeführt werden
unsigned long previousTime1 = 0;                            //Speicherung der vorherigen Intervallzeit1 

//Event 2 alle 3 Sekunden (pH-Messung + Mittelwertbildung)
const unsigned long eventInterval2 = 3 * 1000UL;            //alle 3 Sekunden soll ein Event durchgeführt werden
unsigned long previousTime2 = 0;                            //Speicherung der vorherigen Intervallzeit2

//Event 3 alle 2 Sekunden (Luftqualität, RUN-LED, Füllstandsmessung, Mittelwertbildungen)
const unsigned long eventInterval3 = 2 * 1000UL;            //alle 2 Sekunden soll ein Event durchgeführt werden
unsigned long previousTime3 = 0;                            //Speicherung der vorherigen Intervallzeit3

//Event 4 alle 1 Sekunden (Vorhaltung)
const unsigned long eventInterval4 = 1 * 1000UL;            //alle 2 Sekunden soll ein Event durchgeführt werden
unsigned long previousTime4 = 0;                            //Speicherung der vorherigen Intervallzeit4


//Event 5 alle 7 Sekunden (Aktualisierung der Störmeldeliste)
const unsigned long eventInterval5 = 7 * 1000UL;            //alle 2 Sekunden soll ein Event durchgeführt werden
unsigned long previousTime5 = 0;                            //Speicherung der vorherigen Intervallzeit5 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//7. Hauptschleife

void loop() {
//Dauerhaft Übergaben und Abfragen 

//Übergabe der Systemzeit 
unsigned long currentTime = millis();   //Übergabe der Zeit für Abfragen über Milli() --> aktuelle Zeit ab Start des Microcontrollers

//Leckageüberwachung
leakageDetection();
//--------------------------------------------------------------------------------------------------------------------------------
//Füllstandsmessung
if (currentTime-previousMillisUltraSens >= intervalUltraSens) { //wenn eine Sekunde erreicht
		previousMillisUltraSens = currentTime;                      //Initalisierung der Anfangswert
		if (trigStateUltraSens == LOW){                             //Flankenabfragen und Steuerung der Ultraschallsignale
		  trigStateUltraSens = HIGH;        //Ultraschallsignal EIN
		}
		else {
			(trigStateUltraSens = LOW);       //Ultraschallsignal AUS
		}
	}

	//Überprüfung zur Ausgabe des Ultraschallsignals (serielle Schnittstelle)
	if (currentTime-previousMillisUltraSens >= interval2UltraSens) { //
		previousMillisUltraSens = currentTime;
		if (printStateUltraSens == LOW){
		  printStateUltraSens = HIGH;
      
		}
		else {
			printStateUltraSens = LOW;
		}
	}
  digitalWrite(trigPin,trigStateUltraSens);   //Ausgabe des Ultraschallsignals mit dem jeweiligen Status
	
	duration = pulseIn(echoPin,HIGH);           //Messung des reflektierten Signals (Länge)
	distance = (duration/2) / 29.1;             //Distance ermitteln
  
  //Fehlerminimierung durch Störeinflüsse 
	if (printStateUltraSens = HIGH && !(distance == 0)){                               //wenn keine Störung der Distanzmessung vorhanden
  volume_tank_cal =volume_tank_ges - ((distance*width*100*depth*100) / 1000);
  distanceWithoutFailure = distance;                                                 //Speicherung des letzten Wertes
  }
  else{                                                                              //wenn eine Störung der Distanzmessung vorhanden
  distance = distanceWithoutFailure;                                                 //Verwendung des letzten Wertes
  volume_tank_cal =volume_tank_ges - ((distance*width*100*depth*100) / 1000);
  }
//--------------------------------------------------------------------------------------------------------------------------------
//Zyklisches Abfragen der Werte 
if ((currentTime - previousTime1 >= eventInterval1) || (currentTime == 0)) {    //alle 5 Sekunden
  
  GetEC();                            //Aufruf von EC-Messung
  average_calculation_EC();           //Mittelwertberechnung EC
  
  previousTime1 = currentTime;        //Initalisierung der Anfangswert
 
  }
if ((currentTime - previousTime2 >= eventInterval2) || (currentTime == 0)) {        //alle 3 Sekunden
  
  GetPH();                            //Aufruf von PH-Messung 

  previousTime2 = currentTime;        //Initalisierung der Anfangswert
  }

if ((currentTime - previousTime3 >= eventInterval3) || (currentTime == 0)) {    //alle 2 Sekunden
  
  //Technikebene  
  Temp_Hum_Tech();                                  //Auslesen der Temperatur und Feuchte Technik / -12B1 (DHT11)
  
  //NFT-Bereich Luftqualität
  Temp_Hum_NFT();                                   //Auslesen der Temperatur und Feuchte / -16B1 (DHT11)
  airQuality();                                     //Auslesen der Temperatur, Feuchte, TVOC, CO2 / -17B1 (I2C)
  
  //Mittelwertbildung für Temperatur und Feuchte im NFT-Bereich
  Average_Temp_System = ((tempRoom2 + tempRoom3)/2);                //Temperaturmittelwert  von -16B1 und -17B1
  Average_Moist_System = ((humidityRoom2 + humidityRoom3)/2);       //Feuchtemittelwert     von -16B1 und -17B1                                                                                                 

  //Mittelwertbildung Tankvolumen
  average_calculation_Waterlevel();                 //Mittelwertbildung Tankvolumen

  //Toggeln der StatusLED
  test_LED();
  
  previousTime3 = currentTime;                      //Initalisierung der Anfangswert
}

//Übergabe der aktuelle Zeit
iTimeH = zaehler_hour;
iTimeM = zaehler_min; 

//Aktualisierung der Störmeldliste
if ((currentTime - previousTime5 >= eventInterval5) || (currentTime == 0)) {        //alle 7 Sekunden
  Funktion_Alarm_PlantSensL();
  Funktion_Alarm_PlantSensR();
  Funktion_Alarm_BotSens();
  Funktion_Alarm_PH_Value();
  Funktion_Alarm_EC_Value();
  Funktion_Alarm_Wassertemp();
  Funktion_Alarm_Wasserlevel();
  Sammelstoerung();

  previousTime5 = currentTime;                      //Initalisierung der Anfangswert
  }

//--------------------------------------------------------------------------------------------------------------------------------

//Ablaufsteuerung - (Logik für Ansteuerung von Aktoren)

if (ANLAGE == 1){     //wenn Anlagenschalter auf AUTOMATIK
  
  //Ansteuerung Zirkulationspumpe
  if(Merker_Leakage == false){    //wenn Leckagemeldung nicht aktiv
    NFTPumpOn();                  //Intervallansteuerung der Zirkulationpumpe
  }

  //Aktorenansteuerung (Belüftung und Beleuchtung)
  Lueftung();                   //Steuerung der Belüftung aktiv
  lightNFT_timecontrol();       //Zeitsteuerung NFT-Beleuchtung aktiv
  lightGrowing_timecontrol();   //Zeitsteuerung Anzucht-Beleuchtung aktiv
  
  //Ansteuerung der Dosierungen
  if (DOSIERUNG==1 && Merker_Leakage == false && pumpNFTstatus==true && digitalRead(pumpNFT)==LOW && failureMeasurementsPH == false){    
  //Freigabe der Dosierung wenn keine Leckage detektiert, Zirkulationspumpe EIN und keine Fehlermeldung des PH-Wertes

    //Schritt 1 pH-Dosierung
    if(pHValue>flSollPH == true){ 
    //wenn Grenzwert überschritten
      PHPumpOn();                     //Ansteuerung pH-Dosierungspumpe         
      PHDosageOn = true;              //Hilfsmerker Status der Dosierung = EIN
      digitalWrite(pumpEC,HIGH);      //Verriegelung der EC-Dosierungspumpe
    }
    else{
      PHDosageOn = false;             //Hilfmerker Status der Dosierung = AUS
    }
    
    //Schritt 2 EC-Dosierung
    if(averageEC<flSollEC == true && PHDosageOn ==false && pumpNFTstatus==true && failureMeasurementsEC == false){
    //wenn EC-Grenzwert unterschritten, pH-Dosierung fertiggestellt und keine Fehlermeldung des EC-Wertes 
      ECPumpOn();         //Ansteuerung der EC-Dosierungspumpe
    }
  }  
} 

//--------------------------------------------------------------------------------------------------------------------------------

//Abfrage der Trigger-Funktionen
 myNex.NextionListen();

} 


