//1.
//Bibliotheken und relevante Aufrufe der Bibliotheken

//Standard-Bibiliotheken
#include <Arduino.h>   //Arduino-Standardlib
#include <stdio.h>    //Standardlib
#include <OneWire.h>  //Bibliothek für 1-Leiter-Bussysteme (Wassertemp. / DHT11)
#include <SPI.h>      //???
#include <Wire.h>     //I2C
//#include <avr/power.h>  // Spannungsausfall

//Biblitheken RTC
#include <RTClib.h>   //Realtime-Clock

//Akustik-Bibliotheken (Fehlerbehaftet)
#define TONE_USE_INT
#define TONE_PITCH 440
//Bibliothek kümmern !!!!!!
//#include <Pitch.h>

//Bibliotheken für NEXTION-Display
#include <EasyNextionLibrary.h>
#include <Arduino.h>
#include <EEPROM.h>


//Bibliotheken für Luftqualitätsmessung (I2C)
#include <Adafruit_CCS811.h>
Adafruit_CCS811 ccs;
//Bibliothek für Feuchte und Temp.sensor (I2C)
#include <ClosedCube_HDC1080.h>
ClosedCube_HDC1080 hdc1080;


//Bibliothek für DHTXX-Temperatur-/Feuchtesensoren 
#include <DHT.h>
#include <DallasTemperature.h>

//-------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------
//2.
//Deklerationen / DEFINE / Hilfsmerker

//Erstellung eines Arrays für Zeitdaten
RTC_DS3231 rtc;
char Days_Of_The_Week[7][12] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

//-------------------------------------------------------------------------------------------------------------------------------------

//DHT11 Temperatur und Feuchtesensoren
//Technikebene
#define DHTPIN1 10          //Angabe des verwendeten PIN´s
//Sensor für die Mittelwertbildung im NFT-Bereich
#define DHTPIN2 30          //Angabe des verwendeten PIN´s

//Sensorentyp festlegen
#define DHTTYPE DHT11

//Zuweisung des Typs und Pins
//Technikebene
DHT dht1(DHTPIN1, DHTTYPE);
//Sensor 16B1 für die Mittelwertbildung
DHT dht2(DHTPIN2, DHTTYPE);

//-------------------------------------------------------------------------------------------------------------------------------------
//Füllstandsensor fehlt noch !!! 
//ist auf DO 25 und 26
const int trigPin = 25; //set pin variables
const int echoPin = 26;

//-------------------------------------------------------------------------------------------------------------------------------------

//PH-Messung
#define SensorPin A0          //Analoger Eingang für das Auslesen des pH-Wertes
#define Offset -1.4           //Abweichung hier kompensieren
#define ArrayLenth  20        //Anzahl der Datenspeicher im Array um den Mittelwert des PH-Wertes zu ermitteln

//-------------------------------------------------------------------------------------------------------------------------------------


//-------------------------------------------------------------------------------------------------------------------------------------
//Pumpen, Lüfter und Licht (Digitale Ausgänge)

//Pumpen
#define pumpNFT 2               //Hauptpumpe
bool pumpNFTstatus = false;     //Hauptpumpe Hilfsmerker
#define pumpEC 7                //Dosierpumpe EC
#define pumpPH 6                //Dosierpumpe PH

//Lüftung
#define ventilator 5            //Ablüfter

//Beleuchtung
#define lightNFT 3              //NFT-Licht
#define lightGrowing 4          //Anzucht-Licht

//-------------------------------------------------------------------------------------------------------------------------------------

//Display Paramaeter von davor - kann vermutlich weg
#define navigationButton 13
boolean pressedButton = false;      

//-------------------------------------------------------------------------------------------------------------------------------------

//Akustisches Signal
#define alarmTone 44  	  //PWM-Ansteuerung des Buzzers

//-------------------------------------------------------------------------------------------------------------------------------------

//Terminal Fühler - Wassertemperatur
#define ONE_WIRE_BUS 8                //Datenpin vom Temp.Sensor
OneWire oneWire(ONE_WIRE_BUS);        //Buskommunikation Sensor
DallasTemperature sensors(&oneWire);  //Buskommunikation Sensor

//-------------------------------------------------------------------------------------------------------------------------------------

//Schnittstelle einstellen für das NEXTION-Display (RX1/TX1)
EasyNex myNex(Serial1);

//-------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------
//3.
//Variablen fü die EC-Messung
//Hinweis: Die Variablen müssen vor dem Setup angelegt werden --> Kalbrierungsfunktion wird im Setup aufgerufen !
//Variablen für die EC-Messung
int R1= 1000;                   //Wert des Widerstandes für die EC-Messung über den Stecker
int EC_Read = A2;               //AI: Analoger Wert über Spannungsteiler auslesen 
int ECPower = A1;               //AO: 5V Spannung über den Stecker ins Wasser geleitet
float Temp_C;                   //Temp in Celcius
float Temp_F;                   //Temp in Fahrenheit für internationalen Standard
float Temp1_Value = 0;          //Speicherwert für die Vergleichsmessung
float Temp_Coef = 0.019;        //Temperatur Koeffizient 
//float constanttemp = 18.800;  //Zum Kalibrieren --> NORMAL auskommentieren ??????????????????????????????????????????????????????????????????????????????????????????????????????????????ßß
float offset=0.1;              //Temperaturoffset --> abgeglichen mit EC/PPM/PH-Messgerät

//-------------------------------------------------------------------------------------------------------------------------------------
//Relevant NUR für Kalibrierung (ACHTUNG!)
float Calibration_PPM = 740;                   //gemessener Wert mit anderem Messgerät
float K= 0.06;                                   //Vor der Kalibrierung: 2.4 --> Vergleichswert bei der Kalbrierung muss geändert werden
float PPM_Con=0.5;                              //TDS Factor --> im Datenblatt des Messgerätes enthalten
float CalibrationEC= (Calibration_PPM*2)/1000;  //Vergleich für die EC-Messung
//-------------------------------------------------------------------------------------------------------------------------------------

//Variablen für die EC-Messung
float Temperature;  //gemessene Temperatur über Terminalfühler
float EC;           //Errechneter EC-Wert
float offsetEC = 0.02;    //Kompenstation EC
float EC_at_25 = 0;       //EC-Wert bei 25 Grad
int ppm;            //Errechneter Wert der Anzahl der Teilchen der Lösung in PartsPerMillion
float A_to_D= 0;    //was Ist das genau
float Vin= 5;       //angegebener Wert der Spannung für die Messung
float Vdrop= 0;     //Angabe für Rechteckssignal
float R_Water;      //Widerstand des Wassers
float Value=0;      //Speicherung des Zwischenwerts

//-------------------------------------------------------------------------------------------------------------------------------------
//Dekleration NEXTION-Variablen (Speicherung im EEPROM)
float flSollPlantTemp = 0; //Grenzwert Temperatur Pflanzen
int bytes = 512;
//-------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------
//4.
//Setupinitialisierung
void setup() { 
//EEPROM
// Überwachung der Stromversorgung aktivieren
//power_all_enable();

// Variable aus dem EEPROM wiederherstellen
//EEPROM.get(0, flSollPlantTemp);


//Seriellen Schnittstellen
Serial.begin (9600);                      //Beginn der Seriellen Schnittstelle / Bautrate: 9600
myNex.begin(9600);                        //Beginn der Seriellen Schnittstelle fürs NEXTION-Display

//RealTimeClock INIT
#ifndef ESP8266
  while (!Serial);                      //Warten auf Serielle Kommunikation und Abfrage ob Funktion gegeben
#endif

//Abfrage ob Werte ausgelesen werden
if (! rtc.begin()) {
  Serial.println("Störung Uhrzeit");
  Serial.flush();
  while (1) delay(10);
}

//Bedingung bei Spannungsausfall
if (rtc.lostPower()) {
  Serial.println("RTC lost power, let's set the time!");
  //Datum und Uhrzeit werden bei komplieren übertragen
  //Spannungsversorgung (Batterie) muss entfernt werden
  rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
}

//Beispiel manuelles Einstellen der Uhrzeit
// rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));
//--> 21. Januar 2014 3 Uhr in der Früh

//-------------------------------------------------------------------------------------------------------------------------------------
//Umgebungstemperatur Sensor DHT11 Start
dht1.begin();
dht2.begin(); 


//-------------------------------------------------------------------------------------------------------------------------------------
//I2C - Start
Wire.begin();

//-------------------------------------------------------------------------------------------------------------------------------------
//Temperatursensor EC-Lösung Start
sensors.begin();
//Werte des Terminalfühlers ausgeben
sensors.requestTemperatures();

//-------------------------------------------------------------------------------------------------------------------------------------
//Temperatur und Feuchte des Kombifühlers Start
hdc1080.begin(0x40);

//-------------------------------------------------------------------------------------------------------------------------------------
//Gassensor Start
ccs.begin();

//Probeversuch mit NEXTION-Display starten
//ACHTUNG auskommentiert weil er sonst nicht hochfährt
//So wars davor Display hat gestoppt wenn Sensor nicht verfügbar war
/*
if(!ccs.begin()){
Serial.println("Sensor konnte nicht gestartet werden. Verdrahtung prüfen !");
while(1);
}
//Auf Sensor warten
while(!ccs.available());
*/

//-------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------
//Festlegung PINS (Arduino-MEGA)
//Für die Navigation übers Provisorische Display
pinMode(navigationButton, INPUT_PULLUP);
//attachInterrupt(digitalPinToInterrupt(navigationButton), OLED_NAV, RISING);
//-------------------------------------------------------------------------------------------------------------------------------------
//EC-Messung
pinMode(EC_Read,INPUT);
pinMode(ECPower,OUTPUT);
//-------------------------------------------------------------------------------------------------------------------------------------
//Füllstlandssensor (Ultraschall)
pinMode(trigPin,OUTPUT); //set pinmodes
pinMode(echoPin,INPUT);

//-------------------------------------------------------------------------------------------------------------------------------------
//Zuweisung NFT-System

//Pumpen, Lüfter und Beleuchtung des Systems
pinMode(pumpNFT,OUTPUT);          //Hauptpumpe  NFT
digitalWrite(pumpNFT, HIGH);      //Relais Initalisierung --> Zustand muss festgelgt
pinMode(pumpEC,OUTPUT);           //EC-Pumpe
digitalWrite(pumpEC, HIGH);       //Relais Initalisierung --> Zustand muss festgelgt
pinMode(pumpPH,OUTPUT);           //PH-Pumpe
digitalWrite(pumpPH, HIGH);       //Relais Initalisierung --> Zustand muss festgelgt

//Lüftung
pinMode(ventilator,OUTPUT);       //Ablüfter
digitalWrite(ventilator, HIGH);   //Relais Initialisierung --> Zustand muss festgelegt werden

//Beleuchtung
pinMode(lightNFT,OUTPUT);         //NFT-Licht (40 Watt)
digitalWrite(lightNFT,HIGH);      //Relais Initialisierung --> Zustand muss festgelegt werden
pinMode(lightGrowing,OUTPUT);     //Anzucht-Licht (20 Watt)
digitalWrite(lightGrowing,HIGH);  //Relais Initialisierung --> Zustand muss festgelegt werden

//-------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------
//EC-Messung Kalibrierung (ACHTUNG!)
//Zu Beginn des Systems Kalbrieren
//Calibrate (0,0);  //Muss nach der Kalibrierung auskommentiert sein !!!
                  //Temperature_end, Temperature_begin, Temp_C
//-------------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------------

//Timer für die Dosierung
//Konfiguration Timer 1
  TCCR1A = 0;                         //Register A --> OC1A/OC1B
  TCCR1B = 0;                         //INIT Register B
  TCCR1B |= (1<<CS10)|(1 << CS12);    //PRESCALER: 1024 --> CS10 = 1 , CS12 = 1
  TCNT1 = 0xC2F8;                     //Beginn des Zählzyklus
                                      //65536-(16MHz/1024/1Hz - 1) = 49912 = 0xC2F8 (Ergebnis in HEX)
  TIMSK1 |= (1 << TOIE1);             //Interruptregister
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//5. Funktionen & Variablen
//5. Variablen
//Füllstandsmessung
//Zeitsteuerung
int trigStateUltraSens = LOW;               //Status des Triggers
int intervalUltraSens = 1;                  //Intervall in millisekudend --> Einschalten des Triggers
int interval2UltraSens = 1000;              //Ausgabe auf serieller Schnittstelle in Millisekunden
int printStateUltraSens = LOW;              //Ausgabe als PRINT-Befehl JA/NEIN
unsigned long previousMillisUltraSens = 0;  //vorheriger Wert mit dem der nächste Wert verschachtelt wird

//Bemessungen des zu messenden Körpers
float hoehe = 0.32; //in meter
float tiefe = 0.367;  //in meter
float breite= 0.565;  //in meter
float offsetTanklevel = 2;
float volume_tank_ges = ((hoehe*breite*tiefe)*1000) - offsetTanklevel;
float volume_tank_cal = 0;



//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------------------------------

//5.Funktionen
//Füllstandsmessung
void ultrasonic_measurement(){
  digitalWrite(trigPin,trigStateUltraSens);
	int duration, distance; //variables
	duration = pulseIn(echoPin,HIGH);
	distance = (duration/2) / 29.1;
  
	if (printStateUltraSens = HIGH){
  volume_tank_cal =volume_tank_ges - ((distance*breite*100 *tiefe*100) / 1000);
	/*
  Serial.print(distance);
	Serial.println("cm");
  Serial.println("Volumenmessung in liter:");
	Serial.println(volume_tank_cal);
  */
  }
}

//Variablen akustisches Signal
//Voreinstellungen für Zeitgersteuertes Schalten der akustischen Alarmsignalisierung
//Vorherige Zeit wird hier abgespeichert
unsigned long previousMillisPauseBuzzer=0;
//Intervall des Toggelzustandes
int intervalPauseBuzzer = 1000;
//Statusvariable - Toggeln der Ansteuerung
boolean PauseBuzzerState = false;  
//hier muss die Leckagemeldung hin!!!!!!!!!!!!!!!!!!!!!!!!!!
boolean hilfsmerker = false;
//Akustisches Signal ansteuern
void buzzer(){
  if (PauseBuzzerState==false){
    tone(44,2000);  //1.Pos: Digitaler Ausgang / 2.Pos: Frequenz (Tonlage in Hz)
  }
  else{
    noTone(44);   //Ausschalten des Ausganges
  }
}

//------------------------------------------------------------------------------------------------------------------
//Realtime-Clock

//Variablen - Uhrzeiten für Pumpe NFT
int Start_pumpNFT_hour = 0;
int Start_pumpNFT_minute = 0;
int Stopp_pumpNFT_hour = 23;
int Stopp_pumpNFT_minute = 59;

//Ansteuerung Pumpe NFT
void pumpNFT_with_RTC(DateTime now1){
  //Hauptpumpe
    if (now1.hour() >= 0 && now1.hour() < Start_pumpNFT_hour){//Von 0Uhr bis 14Uhr
      digitalWrite(pumpNFT, HIGH);//Aus
    }
    else if (now1.hour() == Start_pumpNFT_hour && now1.minute() < Start_pumpNFT_minute){//Von 14Uhr bis 14:29Uhr
      digitalWrite(pumpNFT, HIGH);//Aus
    }
    else if (Start_pumpNFT_hour != Stopp_pumpNFT_hour && now1.hour() == Start_pumpNFT_hour && now1.minute() >= Start_pumpNFT_minute){//Von 14:30 bis 15Uhr
      digitalWrite(pumpNFT, LOW);//Ein
    }
    else if (now1.hour() > Start_pumpNFT_hour && now1.hour() < Stopp_pumpNFT_hour){//Von 15Uhr bis 19Uhr
      digitalWrite(pumpNFT, LOW);//Ein
    }
    else if (now1.hour() == Stopp_pumpNFT_hour && now1.minute() < Stopp_pumpNFT_minute){//Von 20Uhr bis 20:49Uhr
      digitalWrite(pumpNFT, LOW);//Ein
    }
    else if (now1.hour() == Stopp_pumpNFT_hour && now1.minute() >= Stopp_pumpNFT_minute){//Von 20:50Uhr bis 21Uhr
      digitalWrite(pumpNFT, HIGH);//Aus
    }   
    else if (now1.hour() > Stopp_pumpNFT_hour && now1.hour() <= 23){//Von 21Uhr bis 23:59Uhr
      digitalWrite(pumpNFT, HIGH);//Aus
    }
    //Innerhalb einer Stunde, also nur für paar Minuten
    if (Start_pumpNFT_hour == Stopp_pumpNFT_hour){
      if (now1.minute() >= Start_pumpNFT_minute && now1.minute() < Stopp_pumpNFT_minute){
        digitalWrite(pumpNFT, LOW);//Ein
      }
      else {
        digitalWrite(pumpNFT, HIGH);//Aus
      }
    }

}

//------------------------------------------------------------------------------------------------------------------

//Uhrzeiten für Beleuchtung NFT
int Start_lightNFT_hour = 7;
int Start_lightNFT_minute = 0;
int Stopp_lightNFT_hour = 19;
int Stopp_lightNFT_minute = 0;

//Ansteuerung Beleuchtung NFT
void lightNFT_with_RTC(DateTime now2){
  //Beleuchtung NFT
    if (now2.hour() >= 0 && now2.hour() < Start_lightNFT_hour){//Von 0Uhr bis 14Uhr
      digitalWrite(lightNFT, HIGH);//Aus
    }
    else if (now2.hour() == Start_lightNFT_hour && now2.minute() < Start_lightNFT_minute){//Von 14Uhr bis 14:29Uhr
      digitalWrite(lightNFT, HIGH);//Aus
    }
    else if (Start_lightNFT_hour != Stopp_lightNFT_hour && now2.hour() == Start_lightNFT_hour && now2.minute() >= Start_lightNFT_minute){//Von 14:30 bis 15Uhr
      digitalWrite(lightNFT, LOW);//Ein
    }
    else if (now2.hour() > Start_lightNFT_hour && now2.hour() < Stopp_lightNFT_hour){//Von 15Uhr bis 19Uhr
      digitalWrite(lightNFT, LOW);//Ein
    }
    else if (now2.hour() == Stopp_lightNFT_hour && now2.minute() < Stopp_lightNFT_minute){//Von 20Uhr bis 20:49Uhr
      digitalWrite(lightNFT, LOW);//Ein
    }
    else if (now2.hour() == Stopp_lightNFT_hour && now2.minute() >= Stopp_lightNFT_minute){//Von 20:50Uhr bis 21Uhr
      digitalWrite(lightNFT, HIGH);//Aus
    }   
    else if (now2.hour() > Stopp_lightNFT_hour && now2.hour() <= 23){//Von 21Uhr bis 23:59Uhr
      digitalWrite(lightNFT, HIGH);//Aus
    }
    //Innerhalb einer Stunde, also nur für paar Minuten
    if (Start_lightNFT_hour == Stopp_lightNFT_hour){
      if (now2.minute() >= Start_lightNFT_minute && now2.minute() < Stopp_lightNFT_minute){
        digitalWrite(lightNFT, LOW);//Ein
      }
      else {
        digitalWrite(lightNFT, HIGH);//Aus
      }
    }

}

//------------------------------------------------------------------------------------------------------------------

//Uhrzeiten für Beleuchtung Anzucht
int Start_lightGrowing_hour = 7;
int Start_lightGrowing_minute = 0;
int Stopp_lightGrowing_hour = 19;
int Stopp_lightGrowing_minute = 0;

//Ansteuerung Beleuchtung Anzucht
void lightGrowing_with_RTC(DateTime now3){
      //Beleuchtung Anzucht
    if (now3.hour() >= 0 && now3.hour() < Start_lightGrowing_hour){//Von 0Uhr bis 14Uhr
      digitalWrite(lightGrowing, HIGH);//Aus
    }
    else if (now3.hour() == Start_lightGrowing_hour && now3.minute() < Start_lightGrowing_minute){//Von 14Uhr bis 14:29Uhr
      digitalWrite(lightGrowing, HIGH);//Aus
    }
    else if (Start_lightGrowing_hour != Stopp_lightGrowing_hour && now3.hour() == Start_lightGrowing_hour && now3.minute() >= Start_lightGrowing_minute){//Von 14:30 bis 15Uhr
      digitalWrite(lightGrowing, LOW);//Ein
    }
    else if (now3.hour() > Start_lightGrowing_hour && now3.hour() < Stopp_lightGrowing_hour){//Von 15Uhr bis 19Uhr
      digitalWrite(lightGrowing, LOW);//Ein
    }
    else if (now3.hour() == Stopp_lightGrowing_hour && now3.minute() < Stopp_lightGrowing_minute){//Von 20Uhr bis 20:49Uhr
      digitalWrite(lightGrowing, LOW);//Ein
    }
    else if (now3.hour() == Stopp_lightGrowing_hour && now3.minute() >= Stopp_lightGrowing_minute){//Von 20:50Uhr bis 21Uhr
      digitalWrite(lightGrowing, HIGH);//Aus
    }   
    else if (now3.hour() > Stopp_lightGrowing_hour && now3.hour() <= 23){//Von 21Uhr bis 23:59Uhr
      digitalWrite(lightGrowing, HIGH);//Aus
    }
    //Innerhalb einer Stunde, also nur für paar Minuten
    if (Start_lightGrowing_hour == Stopp_lightGrowing_hour){
      if (now3.minute() >= Start_lightGrowing_minute && now3.minute() < Stopp_lightGrowing_minute){
        digitalWrite(lightGrowing, LOW);//Ein
      }
      else {
        digitalWrite(lightGrowing, HIGH);//Aus
      }
    }

}

//------------------------------------------------------------------------------------------------------------------
//!!!ACHTUNG!!!!!
//AUFRUF NUR WÄHREND DER KALIBRIERUNG!!!
//Kalibrierung des EC Wertes (Berechnung über Widerstandsmessung 1k Ohm)
void Calibrate (float Temperature_end, float Temperature_begin) // bis jetzt: float Temperature_end, float Temperature_begin, float temp_C
{
//Kalbrierungshinweise 
Serial.println("Kalibrierung hat begonnen!");
Serial.println("Hinweis: Wurde der TDS-Wert des Messgeraetes angepasst?");
Serial.println("Bitte warten. Den Stecker und Temperaturfuehler dauerhaft bedeckt halten mit der Kalibrierfluessigkeit!");
//Einsatz des Terminalfühlers
Temp_C = (sensors.getTempCByIndex(0) + offset); //Temperaturberechnung 
Temp1_Value = Temp_C;
Temperature_begin=Temp_C;
//Kontrolle der Temperatur
Serial.print("Vergleichswert Temperatur 1 (in Grad Celcius): ");
Serial.println(Temp_C);
//Vergleich der Elektrodenspannung (Spannungsteiler)
Value = 0;
int i = 1;
while(i<=10){
digitalWrite(ECPower,HIGH);
A_to_D = analogRead(EC_Read);
A_to_D = analogRead(EC_Read);
digitalWrite(ECPower,LOW);
Value = Value + A_to_D;
i++;
delay(6000);
};
A_to_D=(Value/10);
Temp_C = (sensors.getTempCByIndex(0) + offset); //Temperaturberechnung 
Temp1_Value = Temp_C;
Temperature_end=Temp_C;
//Kontrolle der Temperatur
Serial.print("Vergleichswerte Temperatur 2 (in Grad Celcius): ");
Serial.println(Temp_C);
//Berechnung des Ausgleichsfaktors
EC =CalibrationEC*(1+(Temp_Coef*(Temperature_end-25.0)));
Vdrop= (((Vin)*(A_to_D))/1024.0);
//Widerstand vom Wasser
R_Water=(Vdrop*R1)/(Vin-Vdrop);       
//K-Faktor                      
float K_cal= 1000/(R_Water*EC);                            
//Ausgabe des Ausgleichsfaktors
Serial.print("Ersetze den Ausgleichsfaktor in der Konfigline / K = ");
Serial.println(K_cal);
Serial.print("Temperaturdifferenz zwischen 2 Messungen = ");
//Differenz Berechnung beider gemessener Temperaturen mit einem Versatz von 6 Sekunden
float Temp_Diff=Temperature_end-Temperature_begin;
//Ausgabe der Temperaturdifferenz beider Messungen
Serial.print(Temp_Diff);
Serial.println(" (in Grad Celcius)");
Serial.println("Temperaturdifferenz darf maximal 0.15 abweichen. Wegen der Genauigkeit der Messung");
Serial.println("");
Calibrate ((float )Temperature_end, (float) Temperature_begin);
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------

//EC Wert über Widerstandsmessung A0 und A1
void GetEC()
{
Temp_C = sensors.getTempCByIndex(0) + offset;       //offset: Temperaturausgleich
Temperature = Temp_C;                               //Übergabe Temperatur für EC
digitalWrite(ECPower,HIGH);                         //5v in das Wasser leiten
A_to_D= analogRead(EC_Read);                        //Spannungsteiler auslesen
A_to_D= analogRead(EC_Read);                        //Spannungsteiler auslesen
digitalWrite(ECPower,LOW);                          //5V auf 0V setzen
Vdrop= (Vin*A_to_D) / 1024.0;                       //Berechnung der Spannungsdifferenz (Vergleich)
R_Water = (Vdrop*R1) / (Vin-Vdrop);                 //Berechnung Wasswiderstand
EC = 1000/ (R_Water*K);                             //Berechnung des EC-Wertes in mS (Leitfähigkeit des Wassers)
EC_at_25 = (EC / (1+ Temp_Coef*(Temperature-25.0))) - offsetEC; // muss angepasst werden auf die jeweilige Umgebungstemperatur war davor auf 25 grad
ppm=(EC_at_25)*(PPM_Con*1000);
//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Testfunktion über serielle Schnittstelle
//Für Ausgabe auf dem Seriellen Monitor (Test wenn kein Display) --> normal auskommentiert
//Serial.print(" EC: ");
//Serial.print(EC_at_25);
//Serial.print(" milliSiemens(mS/cm) ");
//Serial.print(ppm);
//Serial.print(" ppm ");
//Serial.print(Temperature);
//Serial.println(" *C ");
//----------------------------------------------------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//PH-Messung
//Variablen
int pHArray[ArrayLenth];   //Store the average value of the sensor feedback
int pHArrayIndex=0;
static float pHValue,voltage;

void GetPH(){
      pHArray[pHArrayIndex++]=analogRead(SensorPin);
      if(pHArrayIndex==ArrayLenth)pHArrayIndex=0;
      voltage = avergearrayPH(pHArray, ArrayLenth)*5.0/1024;
      pHValue = 3.5*voltage+Offset;
      //Test wenn kein Display 
      //Serial.print("Voltage:");
      //Serial.print(voltage,2);
      //Serial.print("    pH value: ");
      //Serial.println(pHValue,2);
      double avergearrayPH();
}

double avergearrayPH(int* arr, int number){
  int i;
  int max,min;
  double avgPH;
  long amount=0;
  if(number<=0){
    Serial.println("Error number for the array to avraging!/n");
    return 0;
  }
  if(number<5){   //less than 5, calculated directly statistics
    for(i=0;i<number;i++){
      amount+=arr[i];
    }
    avgPH = amount/number;
    return avgPH;
  }else{
    if(arr[0]<arr[1]){
      min = arr[0];max=arr[1];
    }
    else{
      min=arr[1];max=arr[0];
    }
    for(i=2;i<number;i++){
      if(arr[i]<min){
        amount+=min;        //arr<min
        min=arr[i];
      }else {
        if(arr[i]>max){
          amount+=max;    //arr>max
          max=arr[i];
        }else{
          amount+=arr[i]; //min<=arr<=max
        }
      }//if
    }//for
    avgPH = (double)amount/(number-2);
  }//if
  return avgPH;
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Luftqualitätsmessung 
//Variablen
int CO2;
float TVOC;
float tempRoom2;
float humidityRoom2;
//Funktion
void airQuality(){
ccs.available();
ccs.readData();
CO2  = ccs.geteCO2();
TVOC =ccs.getTVOC();
tempRoom2 = hdc1080.readTemperature();
humidityRoom2 =hdc1080.readHumidity();
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Visualisierung Umgebungstemperatur (Seite 2)
bool errorDHT=false;

//Uhr Display
//Zeitsteuerung
volatile int zaehler_sek =0;
volatile int zaehler_min = 0 ; 
volatile int zaehler_hour = 4;
volatile int zaehler_day = 5;

//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Testfunktionen (ACHTUNG)
//CO2 und TVOC Funktion
//Normal auskommentiert
/*
void CO2(){
  if(ccs.available()){
    if(!ccs.readData()){
      Serial.print("CO2: ");
      Serial.print(ccs.geteCO2());
      Serial.print("ppm, TVOC: ");
      Serial.println(ccs.getTVOC());
    }
    else{
      Serial.println("ERROR!");
      while(1);
    }
  }
  delay(500);
*/


//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Meldungen anpassen um bei Fehler zu sperren !! 

/* //Auskommentiert weil zu wenige digtiale GPIOS
//Alarm Meldungen
boolean alarm_status = false;  
void alarm(){
if ( ppm < 1 || Temp_C < 10 || EC_at_25 < 0.05 || pHValue > 10 || pHValue <= 4 ){  //Zusätlich: 1.) CO2 == 0 || TVOC == 0 ||tempRoom2 > 50.00 || humidityRoom2>99.00 (für den I2C-Fühler) //2.) || errorDHT == true (DHT-Sensor)
  alarm_status = true;
}
else{
  alarm_status = false;
}

if (alarm_status == true){
  digitalWrite(alarm_LED,HIGH);
}
else{
  digitalWrite(alarm_LED,LOW);
}
}

//Wartungsmeldungen
boolean maintenance_status = false;
void maintenance(){
  if (pHValue <= 5){  //eingestellte Grenzwert 
  maintenance_status = true;
}
else{
  maintenance_status = false;
}

if (maintenance_status == true){
  digitalWrite(maintenance_LED,HIGH);
}
else{
  digitalWrite(maintenance_LED,LOW);
}
}

//RUN-Meldung
boolean run_status = false;
void run(){
  if (alarm_status == false){
  run_status = true;
}
else{
  run_status = false;
}

if (run_status == true){
  digitalWrite(run_LED,HIGH);
}
else{
  digitalWrite(run_LED,LOW);
}
}
*/ //Auskommentiert weil zu wenige digtiale GPIOS

//--------------------------------------------------------------------------------------------------------------------------------
//Hauptschleife
//Variablen für die Hauptschleife

/*
//NFT-Licht
//Zeitkontrolle
int minTimeLight=5;                  //Mindestzeit in Minuten (10 Minuten EIN / 5 Minuten AUS)
int adjustableTimeLight = 20;         //der Wert den wir bekommen mit der Mindestlaufzeit verschachteln
int LightEinschaltzeit=0;            //adjustableTimeNFT+minTime;
//Flankeauswertung wenn jeweilige Zeit über Modulo verglichen
int countLight = 1;
int stateLight = LOW;
int laststateLight = LOW;

//Das Verhältnis der Einschaltzeit ist 2:1 (Einschaltzeit/Ausschaltzeit)
void lightTimeControlNFT(){
  for (int i=1; i<61;i++){
  if (adjustableTimeLight <= minTimeLight){
    LightEinschaltzeit = minTimeLight;
  } 
  else if (adjustableTimeLight==i){
    LightEinschaltzeit = (adjustableTimeLight)/2; //Verschachtelung mit Mindestszeit
  }
  }
}
//Licht-NFT
void NFTLightOn(){
lightTimeControlNFT();
if (zaehler_min % (LightEinschaltzeit) == 0){
  stateLight = HIGH;
}
else{
  stateLight=LOW;
}
 //Flankenwechsel erkennen
 if(laststateLight == LOW && stateLight == HIGH) {
    //abhängig vom counter passende funktion aufrufen
    switch(countLight) {
     case 1:     digitalWrite(lightNFT,LOW);
                 break;
     case 2:     digitalWrite(lightNFT,LOW);
                 break;
     case 3:     digitalWrite(lightNFT,HIGH);
                 break;            
    }   
    //zähler erhöhen
    countLight++;
    //zähler zurücksetzen
    if(countLight == 4) {
    countLight = 1;
    }
 }
  laststateLight = stateLight;   //letzten zustand merken 
}
*/

//Hauptpumpe NFT
int minTimeNFT=5;                  //Mindestzeit in Minuten (10 Minuten EIN / 5 Minuten AUS)
int adjustableTimeNFT = 20;         //der Wert den wir bekommen mit der Mindestlaufzeit verschachteln
int NFTEinschaltzeit=0;            //adjustableTimeNFT+minTime;
//Flankeauswertung wenn jeweilige Zeit über Modulo verglichen
int countNFT = 1;
int stateNFT = LOW;
int laststateNFT = LOW;

//Das Verhältnis der Einschaltzeit ist 2:1 (Einschaltzeit/Ausschaltzeit)
void pumpTimeControlNFT(){
  for (int i=1; i<61;i++){
  if (adjustableTimeNFT <= minTimeNFT){
    NFTEinschaltzeit = minTimeNFT;
  } 
  else if (adjustableTimeNFT==i){
    NFTEinschaltzeit = (adjustableTimeNFT)/2; //Verschachtelung mit Mindestszeit
  }
  }
}

void NFTPumpOn(){
pumpTimeControlNFT();
if (zaehler_min % (NFTEinschaltzeit) == 0){
  stateNFT = HIGH;
}
else{
  stateNFT=LOW;
}
 //Flankenwechsel erkennen
 if(laststateNFT == LOW && stateNFT == HIGH) {
    //abhängig vom counter passende funktion aufrufen
    switch(countNFT) {
     case 1:     digitalWrite(pumpNFT,LOW);
                  pumpNFTstatus=true;
                 break;
     case 2:     digitalWrite(pumpNFT,LOW);
                  pumpNFTstatus=true;
                 break;
     case 3:     digitalWrite(pumpNFT,HIGH);
                pumpNFTstatus=false;
                 break;            
    }   
    //zähler erhöhen
    countNFT++;
    //zähler zurücksetzen
    if(countNFT == 4) {
    countNFT = 1;
    }
 }
  laststateNFT = stateNFT;   //letzten zustand merken 
}



//Dosierung PH
int waitMinDosagePH=1;                            //Für Display eventuell --> Eingabe der Wartzeit in Minuten
int proportionFixPH = waitMinDosagePH * 30;           //Für die Anzeige auf dem Display --> Berechnung der Proportionalen Zeitsteuerung --> Wartezeit= proportionFix * adjustableTimePH / z.B. 5 Minuten entspricht proportion
                                                  //proportionFixPH = Wartezeit / AdjustableTimePH --> = (60s) / 2 = 30 (ERGEBNIS) --> pro Minute einen Faktor um 30 erhöhen
int proportionPH = proportionFixPH +1;            //Verhältnis der Dosierung zu Warte zeit 1 / Proportion --> BSP.: 1 / 60 --> umso länger ich Dosiere umso länger wartet man !!!!
int minTimePH=2;                                //Mindestzeit in Minuten (10 Minuten EIN / 5 Minuten AUS)
int adjustableTimePH = 10;                       //Darf nicht gleich 1 sein !!! 
int PHEinschaltzeit=10;                          //adjustableTimeNFT+minTime;
//Flankeauswertung wenn jeweilige Zeit über Modulo verglichen
int countPH = 1;
int statePH = LOW;
int laststatePH = LOW;

//Das Verhältnis der Einschaltzeit ist 2:1 (Einschaltzeit/Ausschaltzeit)
void dosingpumpTimePH(){
  for (int i=1; i<61;i++){
  if (adjustableTimePH < minTimePH){
    PHEinschaltzeit = minTimePH;
  } 
  else if (adjustableTimePH==i){
    PHEinschaltzeit = adjustableTimePH; //Verschachtelung mit Mindestszeit Anpassung für Werte 
    }
  
  }
}


//Hilfsmerker Eindosierung
int dosierungsanzahl;

void PHPumpOn(){
dosingpumpTimePH();
if (zaehler_sek % (PHEinschaltzeit) == 0){
  statePH = HIGH;
}
else{
  statePH=LOW;
}
 //Flankenwechsel erkennen
 if(laststatePH == LOW && statePH == HIGH) {
    //abhängig vom counter passende funktion aufrufen
    switch(countPH) {
     case 1:    digitalWrite(pumpPH,LOW);
                //Serial.print("Anzahl Dosierung PH: ");
                //Serial.println(dosierungsanzahl++);
                //Serial.println("PH-Wert: ");
                //Serial.println(pHValue);
                break; 
    default:    digitalWrite(pumpPH,HIGH);
                break;

    }   
    //zähler erhöhen
    countPH++;
    //zähler zurücksetzen
    if(countPH == proportionPH) {
    countPH = 1;
    }
 }
  laststatePH = statePH;   //letzten zustand merken 
}

//Sperre der Dosierung (erst PH dann EC-Wert korrigieren)
//Merker um die EC-Dosierung zu blockieren bis der PH-Wert erreicht ist
bool PHDosageOn = false;

//Dosierung EC
int waitMinDosageEC=1;                          //Wartezeit in Minuten zum Nachdosieren (Einstellbar über Display)
int proportionFixEC=waitMinDosageEC * 30;       //Für die Anzeige auf dem Display --> Berechnung der Proportionalen Zeitsteuerung --> Wartezeit= proportionFix * adjustableTimePH
int proportionEC = proportionFixEC +1;          //Verhältnis der Dosierung zu Warte zeit 1 / Proportion --> BSP.: 1 / 60 --> umso länger ich Dosiere umso länger wartet man !!!!
int minTimeEC=2;                                //Mindestzeit in Minuten (10 Minuten EIN / 5 Minuten AUS)
int adjustableTimeEC = 10;                       //der Wert den wir bekommen mit der Mindestlaufzeit verschachteln
int ECEinschaltzeit=10;                          //adjustableTimeNFT+minTime;
//Flankeauswertung wenn jeweilige Zeit über Modulo verglichen
int countEC = 1;
int stateEC = LOW;
int laststateEC = LOW;

//Das Verhältnis der Einschaltzeit ist 2:1 (Einschaltzeit/Ausschaltzeit)
void dosingpumpTimeEC(){
  for (int i=1; i<61;i++){
  if (adjustableTimeEC < minTimeEC){
    ECEinschaltzeit = minTimeEC;
  } 
  else if (adjustableTimeEC==i){
    ECEinschaltzeit = adjustableTimeEC; //Verschachtelung mit Mindestszeit Anpassung für Werte 
    }
  
  }
}

void ECPumpOn(){
dosingpumpTimeEC();
if (zaehler_sek % (ECEinschaltzeit) == 0 && EC_at_25> 0.1){   // 0.1 --> ist der Grenzwert von dem Wasser was eingfüllt wird / es dauert gewisse Zeit bis die erste Messung zustande kommt
  stateEC = HIGH;
}
else{
  stateEC=LOW;
}
 //Flankenwechsel erkennen
 if(laststateEC == LOW && stateEC == HIGH) {
    //abhängig vom counter passende funktion aufrufen
    switch(countEC) {
     case 1:    digitalWrite(pumpEC,LOW);
                break; 
    default:    digitalWrite(pumpEC,HIGH);
                break; 
    //case proportionFixEC:    digitalWrite(pumpEC,HIGH);
     //           break;

    }   
    //zähler erhöhen
    countEC++;
    //Serial.println(countEC);
    //zähler zurücksetzen
    if(countEC == proportionEC) {
    countEC = 1;
    }
 }
  laststateEC = stateEC;   //letzten zustand merken 
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Variablen Display

//-------------------------------------------------------------------------------------------------------------------------------------
//Display
//Uhrzeit
String Uhrzeit = "";
//Freigaben
int ANLAGE = 0;
int DOSIERUNG = 0;
//Integer Variablen
int iStandby = 0; //Standby Zeit (s)
int iTimeH = 0; //aktuelle Uhrzeit Stunden 0-23
int iTimeM = 0;//(now.hour(), DEC);//aktuelle Uhrzeit Minuten 0-59


int iLight40FH = Start_pumpNFT_hour; //NFT Licht Einschaltdauer von (Stunden)
int iLight40FM = Start_pumpNFT_minute; //NFT Licht Einschaltdauer von (Minuten)
int iLight40TH = Stopp_pumpNFT_hour; //NFT Licht Einschaltdauer bis (Stunden)
int iLight40TM = Stopp_pumpNFT_minute; //NFT Licht Einschaltdauer bis (Minuten)
int iLight20FH = 0; //Anzucht Licht Einschaltdauer von (Stunden)
int iLight20FM = 0; //Anzucht Licht Einschaltdauer von (Minuten)
int iLight20TH = 0; //Anzucht Licht Einschaltdauer bis (Stunden)
int iLight20TM = 0; //Anzucht Licht Einschaltdauer bis (Minuten)
int iPumpOn = 0; // Einschaltzyklus Pumpe (min)
//Grenzwerte
//Auskommentiert !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//float flSollPlantTemp = 0; //Grenzwert Temperatur Pflanzen
float flSollPlantMois = 0; //Grenzwert Feuchte Pflanzen
float flSollCO2 = 0; //Grenzwert CO2
float flSollPH = 0; //Grenzwert PH
float flSollEC = 0; //Grenzwert EC

//DHT11 Variablen
//test!!!!!!!!!!!!!!!!!!!
float tempRoom1;
float humidityRoom1;
float tempRoom3;
float humidityRoom3;
//Lüftung
float Average_Temp_System;
float Average_Moist_System;

//Vemutlich Weg
float Setpoint_Temp_System = 19.5;
float Setpoint_Moist_System = 65.5;

//Hystereswerte für Lüftungansteuerung
float Hysteresis_Temp_System = 1.0;
float Hysteresis_Moist_System = 5.0;
float Hysteresis_CO2_System = 150.0;


String stSollPlantTemp = String(flSollPlantTemp); //Grenzwert Temperatur Pflanzen
String stSollPlantMois = String(flSollPlantMois); //Grenzwert Feuchte Pflanzen
String stSollCO2 = String(flSollCO2); //Grenzwert CO2
String stSollPH = String(flSollPH); //Grenzwert PH
String stSollEC = String(flSollEC); //Grenzwert EC
//Messwerte
String stIstPlantTemp = String(Average_Temp_System); //Istwert Temperatur Pflanzen
String stIstPlantMois = String(Average_Moist_System); //Istwert Feuchte Pflanzen
String stIstCO2 = String(CO2);//"4321";//String(ccs.geteCO2());//String(CO2); //Istwert CO2
String stIstPH = String(pHValue); //Istwert PH
String stIstEC = String(EC_at_25); //Istwert EC



String stBotTemp = String(tempRoom1); //Temperatur Technik
String stBotMois = String(humidityRoom1); //Feuchte Technik
String stTDS = ""; //TDS
String stWatertemp = String(Temp_C); //Wassertemperatur
String stTanklevel =String(volume_tank_cal); //Höhenstand Tank

void string_display(){
stSollPlantTemp = String(flSollPlantTemp); //Grenzwert Temperatur Pflanzen
stSollPlantMois = String(flSollPlantMois); //Grenzwert Feuchte Pflanzen
stSollCO2 = String(flSollCO2); //Grenzwert CO2
stSollPH = String(flSollPH); //Grenzwert PH
stSollEC = String(flSollEC); //Grenzwert EC
//Messwerte
stIstPlantTemp = String(Average_Temp_System); //Istwert Temperatur Pflanzen
stIstPlantMois = String(Average_Moist_System); //Istwert Feuchte Pflanzen
stIstCO2 = String(CO2);//"4321";//String(ccs.geteCO2());//String(CO2); //Istwert CO2
stIstPH = String(pHValue); //Istwert PH
stIstEC = String(EC_at_25); //Istwert EC
stBotTemp = String(tempRoom1); //Temperatur Technik
stBotMois = String(humidityRoom1); //Feuchte Technik
stTDS = String(ppm); //TDS
stWatertemp = String(Temp_C); //Wassertemperatur
stTanklevel = String(volume_tank_cal); //Höhenstand Tank
}

//Funktionen für Displayaktionen
//Pascal
void trigger0(){ //Einstellungen speichern Display/Uhrzeit
  iStandby = myNex.readNumber("Settings.iStandby.val");
  iTimeH = myNex.readNumber("Settings.iSetTimeH.val");
  iTimeM = myNex.readNumber("Settings.iSetTimeM.val");
  rtc.adjust(DateTime(0, 0, 0, iTimeH, iTimeM, 0));
  //Uhrzeit = String(iTimeH) + ":" + String(iTimeM);
}

void trigger1(){ //Hand Anlage Ein/Aus
  if (myNex.readNumber("Manual.swAnlage.val") == 1){
    ANLAGE = 1;
  }
  else ANLAGE = 0;
}

void trigger2(){ //Hand Anzucht-Beleuchtung
  if (myNex.readNumber("Manual.swLight20.val") == 1){
    digitalWrite(lightGrowing, LOW);
  }
  else digitalWrite(lightGrowing, HIGH);
}

void trigger3(){ //Hand NFT-Beleuchtung
  if (myNex.readNumber("Manual.swLight40.val") == 1){
    digitalWrite(lightNFT, LOW);
  }
  else digitalWrite(lightNFT, HIGH);
}

void trigger4(){ //Hand Belüftung
  if (myNex.readNumber("Manual.swVent.val") == 1){
    digitalWrite(ventilator, LOW);
  }
  else digitalWrite(ventilator, HIGH);
}

void trigger5(){ //Hand Freigabe Dosierung
  if (myNex.readNumber("Manual_2.swDos.val") == 1){
    DOSIERUNG = 1;
  }
  else DOSIERUNG = 0;
}

void trigger6(){ //Hand PH-Dosierung
  if (myNex.readNumber("Manual_2.swPH.val") == 1){
    digitalWrite(pumpPH, LOW);
  }
  else digitalWrite(pumpPH, HIGH);
}

void trigger7(){ //Hand Dünger-Dosierung
  if (myNex.readNumber("Manual_2.swDung.val") == 1){
    digitalWrite(pumpEC, LOW);
  }
  else digitalWrite(pumpEC, HIGH);
}

void trigger8(){ //Hand Pumpe Haupttank
  if (myNex.readNumber("Manual_2.swPump.val") == 1){
    digitalWrite(pumpNFT, LOW);
  }
  else digitalWrite(pumpNFT, HIGH);
}

void trigger9(){ //Zeitsteuerung NFT-Beleuchtung
  Start_lightNFT_hour = myNex.readNumber("Times40.iLight40FH.val");
  Start_lightNFT_minute = myNex.readNumber("Times40.iLight40FM.val");
  Stopp_lightNFT_hour = myNex.readNumber("Times40.iLight40TH.val");
  Stopp_lightNFT_minute = myNex.readNumber("Times40.iLight40TM.val");
}

void trigger10(){ //Zeitsteuerung Pumpe
  iPumpOn = myNex.readNumber("TimesPump.iPumpOn.val");
}

void trigger11(){ //Zeitsteuerung Anzucht-Beleuchtung
  Start_lightGrowing_hour = myNex.readNumber("Times20.iLight20FH.val");
  Start_lightGrowing_minute = myNex.readNumber("Times20.iLight20FM.val");
  Stopp_lightGrowing_hour = myNex.readNumber("Times20.iLight20TH.val");
  Stopp_lightGrowing_minute = myNex.readNumber("Times20.iLight20TM.val");
}

void trigger12(){ //Sollwert Temperatur Pflanzen
stSollPlantTemp = myNex.readStr("PlantTemp.tSollPlantTemp.txt");
flSollPlantTemp = stSollPlantTemp.toFloat();
}

void trigger13(){ //Sollwert Feuchte Pflanzen
stSollPlantMois = myNex.readStr("PlantMoisture.tSollPlantMois.txt");
flSollPlantMois = stSollPlantMois.toFloat();
}

void trigger14(){ //Sollwert CO²
stSollCO2 = myNex.readStr("CO2.tSollCO2.txt");
flSollCO2 = stSollCO2.toFloat();
}

void trigger15(){ //Sollwert PH
stSollPH = myNex.readStr("PH.tSollPH.txt");
flSollPH = stSollPH.toFloat();
}

void trigger16(){ //Sollwert EC
stSollEC = myNex.readStr("EC.tSollEC.txt");
flSollEC = stSollEC.toFloat();
}

void trigger17(){ //Einlesen der Schalter-Zustände / Handbetrieb Seite 1
myNex.writeNum("Manual.swAnlage.val", ANLAGE);
myNex.writeNum("Manual.swLight20.val", !(digitalRead(lightGrowing)));
myNex.writeNum("Manual.swLight40.val", !(digitalRead(lightNFT)));
myNex.writeNum("Manual.swVent.val", !(digitalRead(ventilator)));
}

void trigger18(){ //Einlesen der Schalter-Zustände / Handbetrieb Seite 2
myNex.writeNum("Manual_2.swDos.val", DOSIERUNG);
myNex.writeNum("Manual_2.swPH.val", !(digitalRead(pumpPH)));
myNex.writeNum("Manual_2.swDung.val", !(digitalRead(pumpEC)));
myNex.writeNum("Manual_2.swPump.val", !(digitalRead(pumpNFT)));
}
//----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Variablen test
int duration=0 ;
int distance= 0; //variables



//Lüftung
void Lueftung(){
  //if(  (Average_Temp_System >= (Setpoint_Temp_System + Hysteresis_Temp_System))   ||    (Average_Moist_System >= (Setpoint_Moist_System + Hysteresis_Moist_System))    ){
  if(  (Average_Temp_System >= (flSollPlantTemp + Hysteresis_Temp_System))   ||    (Average_Moist_System >= (flSollPlantMois + Hysteresis_Moist_System))  ||    (CO2 >= (flSollCO2 + Hysteresis_CO2_System))    ){
    //Ventilator ein
    Serial.println("VENT ON");
    Serial.println(CO2);
    digitalWrite(ventilator, LOW);
  }
  else if(  (Average_Temp_System < (flSollPlantTemp - Hysteresis_Temp_System))  &&   (Average_Moist_System < (flSollPlantMois - Hysteresis_Moist_System))   &&    (CO2 < (flSollCO2 + Hysteresis_CO2_System))  ){
    //Ventilator aus
    digitalWrite(ventilator, HIGH);
    Serial.println("VENT OFF");
  }
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------


//Zeitsteuerung über MILLIS()
//Event 1 alle 5 Sekunden
const unsigned long eventInterval1 = 5 * 1000UL;            //alle 5 Sekunden soll ein Event durchgeführt werden
unsigned long previousTime1 = 0;                      //Speicherung der vorherigen Zeit1

//Event 2 alle 3 Sekunden
const unsigned long eventInterval2 = 3 * 1000UL;            //alle 3 Sekunden soll ein Event durchgeführt werden
unsigned long previousTime2 = 0;

//Event 3 alle 2 Sekunden
const unsigned long eventInterval3 = 2 * 1000UL;            //alle 2 Sekunden soll ein Event durchgeführt werden
unsigned long previousTime3 = 0; 

//Event 4 
//Pumpensteuerung (Intervallsteuerung Hauptpumpe alle 10 Minuten)
// muss noch angepasst werden Intervalle übergeben nur nicht mit MILLIS()


//Event 5 für 1 ms (FÜllstand Trigger)
//Pumpensteuerung (Intervallsteuerung Hauptpumpe)
const unsigned long eventInterval5 = 2 * 1000UL;           //10 * 60 * 1000;  //alle 10 Minuten soll ein Event durchgeführt werden
unsigned long previousTime5 = 0;

//Event 6 alle 2 Sekunde (Füllstandsensor Ausgabe)
//Pumpensteuerung (Intervallsteuerung Hauptpumpe)
const unsigned long eventInterval6 = 2 * 1000UL;           //10 * 60 * 1000;  //alle 10 Minuten soll ein Event durchgeführt werden
unsigned long previousTime6 = 0;

//entfälllt vermutlich !!!!!
//Event 7 alle 1 Minuten
//Verzögerung der Dosierung
const unsigned long eventInterval7 = 1 * 60 * 1000UL;           //10 * 60 * 1000;  //alle 10 Minuten soll ein Event durchgeführt werden
unsigned long previousTime7 = 0;

int initial = 0;                                      //Initialwert für das Laden der Startwerte
//--------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------
//Testoberfläche 
unsigned long currentMillisBuzzer = millis();
int logSerial =0;


void loop() {
//Übergabe der Zeit für Abfragen über Milli() --> aktuelle Zeit ab Start des Microcontrollers
unsigned long currentTime = millis();


//TEST Anfang
//Füllstandsensor
if (currentTime-previousMillisUltraSens >= intervalUltraSens) { //check "blink without delay" code
		previousMillisUltraSens = currentTime;
		if (trigStateUltraSens == LOW){
			(trigStateUltraSens = HIGH);
		}
		else {
			(trigStateUltraSens = LOW);
		}
	}
	// printing if statement
	if (currentTime-previousMillisUltraSens >= interval2UltraSens) { //check "blink without delay" code
		previousMillisUltraSens = currentTime;
		if (printStateUltraSens == LOW){
			(printStateUltraSens = HIGH);
      
		}
		else {
			(printStateUltraSens = LOW);
		}
	}
  digitalWrite(trigPin,trigStateUltraSens);
	
	duration = pulseIn(echoPin,HIGH);
	distance = (duration/2) / 29.1;
  
	if (printStateUltraSens = HIGH && !(distance == 0)){
  volume_tank_cal =volume_tank_ges - ((distance*breite*100 *tiefe*100) / 1000);
	/*
  Serial.print(distance);
	Serial.println("cm");
  Serial.println("Volumenmessung in liter:");
	Serial.println(volume_tank_cal);
  */
  }

  //ultrasonic_measurement();
  
	




//digitalWrite(lightNFT,HIGH);
//Test Übergabe Display
string_display();

//Test ENDE


//Übergabe der aktuellen Zeit
DateTime now = rtc.now(); 
iTimeH = now.hour();
iTimeM = now.minute();

if(iTimeM > 10 && iTimeH >10){
Uhrzeit = String(iTimeH) + ":" + String(iTimeM);
}
else if (iTimeM < 10 && iTimeH < 10){
Uhrzeit = "0" + String(iTimeH) + ":" + "0" + String(iTimeM);
}
else if (iTimeM < 10){
  Uhrzeit = String(iTimeH) + ":" + "0" + String(iTimeM);
}
else if (iTimeH < 10){
  Uhrzeit = "0" + String(iTimeH) + ":" + String(iTimeM);
}






//TEST ENDE

//--------------------------------------------------------------------------------------------------------------------------------
//Status der Anlage --> auskommentiert weil zu wenige GPIOS
//alarm();
//run();
//maintenance();
//--------------------------------------------------------------------------------------------------------------------------------
//Akustischer Alarm
//NEUNEU Ansteuerung Buzzer
if (hilfsmerker == false){
   //unsigned long currentMillisBuzzer = millis(); // auskommentiert
    if ((unsigned long)(currentMillisBuzzer - previousMillisPauseBuzzer) >= intervalPauseBuzzer) {
      buzzer();
      PauseBuzzerState = !PauseBuzzerState;
      previousMillisPauseBuzzer = currentMillisBuzzer;
 }
}
else{
    noTone(44);   //Ausschalten des Ausganges
}

//--------------------------------------------------------------------------------------------------------------------------------
  //NEUNEU
  //DHT11 Sensoren
  //----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Raumtemperatur und -feuchte DHT11 (für Technikebene)

//Variablen für die Funktion
tempRoom1= dht1.readTemperature();
humidityRoom1 = dht1.readHumidity();
//Raumtemperatur und -feuchte DHT11
//Variablen für die Funktion
tempRoom3= dht2.readTemperature();
humidityRoom3 = dht2.readHumidity();

//--------------------------------------------------------------------------------------------------------------------------------


//Zyklisches Abfragen der Werte

//Anpassung erst PH-Messung und EC-Messung darf nicht gleichzeitig passieren --> Problem das wert sich gegenseitig verfälschen !!! 
//alle 3 sekunden wenn die eine messung nicht an ist 

//Anpassung bei Overflow muss noch geändert werden (ACHTUNG!!)
if ((currentTime - previousTime1 >= eventInterval1) || (currentTime == 0)) {                  //alle 5 Sekunden
  GetEC();  
  //Mittelwerte bilden
  Average_Temp_System = (tempRoom2 + tempRoom3)/2;
  Average_Moist_System = (humidityRoom2 + humidityRoom3)/2; 
  //NEUNEUENDE
                                                                                   //Aufruf und Abarbeitung für den EC-Wert                                  
  previousTime1 = currentTime;                                                                 //Initalisierung der Anfangswert
  }
if ((currentTime - previousTime2 >= eventInterval2) || (currentTime == 0)) {                  //alle 3 Sekunden
  GetPH();
  previousTime2 = currentTime;                                                                 //Initalisierung der Anfangswert
  }
if ((currentTime - previousTime3 >= eventInterval3) || (currentTime == 0)) {                    //alle 2 Sekunden
  //Temp_Hum_Room1();                                                                            //Aufruf und Abarbeitung für Raumtemperatur/-feuchte 1   (Technikebene)
  //Temp_Hum_Room3();                                                                            //Aufruf und Abarbeitung für Raumtemperatur/-feuchte 3 (Anzuchtebene links)
  airQuality();                                                                                //Aufruf Luftqualität und Raumtemperatur/-Feuhte 2
  previousTime3 = currentTime;                                                                //Initalisierung der Anfangswert
  }


//NEU: Zeitsteuerung und Ansteurung Hauptpumpe
//NFTPumpOn();
if (ANLAGE == 1){
//NEUNEU
NFTPumpOn();
//Ansteuerung NFT-Pumpe über Uhrenkanal
pumpNFT_with_RTC(now);
//Ansteuerung Ablüfter
Lueftung();
//Ansteuerung Licht über Uhrenkanäle
lightNFT_with_RTC(now);
lightGrowing_with_RTC(now);
//Fliegt Raus
//NFTLightOn();
if (DOSIERUNG==1){
Serial.println("TEST");
NFTPumpOn();
//Dosierungen
//NEU: Zeitsteuerung und Ansteuerung PH-Dosierpumpe
//Dosierung der PH-Down-Lösung wird solange blockiert bis der gewünschte EC-Wert erreicht ist 
if(pHValue>flSollPH == true){ //&& pumpNFTstatus == true ){                                              //Grenzwertvergeben + Dosierung nur möglich wenn Zirkulationspumpe EIN
PHPumpOn();
PHDosageOn = true;
digitalWrite(pumpEC,HIGH);          //Ausschalten der Pumpe wenn PH-Wert für die Nährstoffdosierung angepasst wird
 //Serial.println("PH EIN");
}
else{
  PHDosageOn = false;
  //Serial.println("PH AUS");
}
////NEU: Zeitsteuerung und Ansteuerung EC-Dosierpumpe
if(EC_at_25<0.320 == true && PHDosageOn ==false ){//&& pumpNFTstatus == true ){    
ECPumpOn();
 //Serial.println("EC EIn");
}
else{
  //Serial.println("EC AUS");
}
}
}
else{
  digitalWrite(pumpNFT,HIGH);
  digitalWrite(pumpEC,HIGH);
  digitalWrite(pumpPH,HIGH);
  digitalWrite(lightNFT,HIGH);
  digitalWrite(lightGrowing,HIGH);
  digitalWrite(ventilator,HIGH);
}

//lSollPlantTemp

//--------------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------------------------
//Display Aktualisierung und Abfrage
refreshDisplay();
//Abfrage der Trigger-Funktionen
 myNex.NextionListen();
//--------------------------------------------------------------------------------------------------------------------------------
//ENDLOOP

//Test

 // Stromversorgungsstatus überprüfen
  //Auskommentiert !! Andere Lösung
  /*
  if (power_get_interrupt_flag()) {
    // Spannungsverlust erkannt, Variable im EEPROM speichern
    EEPROM.put(0, flSollPlantTemp);
    EEPROM.commit();
  }
  */


return 0;
} 


void refreshDisplay(){ //Einlesen der Zustände und Variablen in der Loop
myNex.writeStr("Home.tUhrzeit.txt", Uhrzeit);
//myNex.writeNum("Settings.iStandby.val", iStandby);
//myNex.writeNum("Settings.iSetTimeH.val", iTimeH);
//myNex.writeNum("Settings.iSetTimeM.val", iTimeM);
//myNex.writeNum("Times40.iLight40FH.val", iLight40FH);
//myNex.writeNum("Times40.iLight40FM.val", iLight40FM);
//myNex.writeNum("Times40.iLight40TH.val", iLight40TH);
//myNex.writeNum("Times40.iLight40TM.val", iLight40TM);
//myNex.writeNum("TimesPump.iPumpOn.val", iPumpOn);
//myNex.writeNum("Times20.iLight20FH.val", iLight20FH);
//myNex.writeNum("Times20.iLight20FM.val", iLight20FM);
//myNex.writeNum("Times20.iLight20TH.val", iLight20TH);
//myNex.writeNum("Times20.iLight20TM.val", iLight20TM);
//myNex.writeStr("PlantTemp.tSollPlantTemp.txt", stSollPlantTemp);
myNex.writeStr("PlantTemp.tIstPlantTemp.txt", stIstPlantTemp);
//myNex.writeStr("PlantMoisture.tSollPlantMois.txt", stSollPlantMois);
myNex.writeStr("PlantMoisture.tIstPlantMois.txt", stIstPlantMois);
//myNex.writeStr("CO2.tSollCO2.txt", stSollCO2);
myNex.writeStr("CO2.tIstCO2.txt", stIstCO2);
myNex.writeStr("BotTemp.tBotTemp.txt", stBotTemp);
myNex.writeStr("BotTemp.tBotMois.txt", stBotMois);
//myNex.writeStr("PH.tSollPH.txt", stSollPH); 
myNex.writeStr("PH.tIstPH.txt", stIstPH);
//myNex.writeStr("EC.tSollEC.txt", stSollEC);
myNex.writeStr("EC.tIstEC.txt", stIstEC);
myNex.writeStr("TDS.tTDSppm.txt", stTDS);
myNex.writeStr("TDS.tWatertemp.txt", stWatertemp);
myNex.writeStr("Tanklevel.tTanklevel.txt", stTanklevel);
}

//Timer für Dosierung
ISR(TIMER1_OVF_vect)                              //Interrupción del TIMER1 
{
  TCNT1 = 0xC2F7;                                 // Reniciar Timer1
  zaehler_sek=zaehler_sek + 1;
  if (zaehler_sek==60){
    zaehler_sek = 0;
    zaehler_min =zaehler_min + 1;
  }
  if (zaehler_min == 60){
    zaehler_min = 0;
    zaehler_hour= zaehler_hour+1;
  }
  if (zaehler_hour == 24){
    zaehler_hour = 0;
    zaehler_day = zaehler_day + 1;
  }
  //Serial.println(zaehler_sek);
}



//Test funktionen über Seriellen Monitor
  //Anfang LOG
  /*
  Serial.print("Anzahl der LOGS: ");
  Serial.println(logSerial++);
  Serial.println("________________________________________________________________________");
  Serial.println("Temp MW: ");
  Serial.println(Average_Temp_System);
  Serial.println("Feuchte MW: ");
  Serial.println(Average_Moist_System);
  

  Serial.println("________________________________________________________________________");
  Serial.println("Raumtemp(DHT11)");
  Serial.println(tempRoom1);
  Serial.println("Luftfeucht (DHT11)");
  Serial.println(humidityRoom1);
  Serial.println("________________________________________________________________________");
    Serial.println("Raumtemp(DHT11)");
  Serial.println(tempRoom3);
  Serial.println("Luftfeucht (DHT11)");
  Serial.println(humidityRoom3);
  Serial.println("________________________________________________________________________");
  Serial.print("Anzahl Dosierung PH: ");
  Serial.println(dosierungsanzahl);
  Serial.println("PH-Wert: ");
  Serial.println(pHValue);
  Serial.println("________________________________________________________________________");
  Serial.println("EC-Wert: ");
  Serial.println(EC_at_25);
  Serial.println("Temperaturwasser EC: ");
  Serial.println(Temp_C);
  Serial.println("________________________________________________________________________");
    Serial.println("CO2- Wert: ");
  Serial.println(CO2);
    Serial.println("TVOC- Wert: ");
  Serial.println(TVOC);
  Serial.println("Temperatur OBEN: ");
  Serial.println(tempRoom2);
  Serial.println("Feuchte OBEN: ");
  Serial.println(humidityRoom2);
  Serial.println("________________________________________________________________________");
   //Anzeige der aktuellen Uhrzeit im Serial Monitor
    Serial.print(now.year(), DEC);
    Serial.print('/');
    Serial.print(now.month(), DEC);
    Serial.print('/');
    Serial.print(now.day(), DEC);
    Serial.print(" (");
    Serial.print(Days_Of_The_Week[now.dayOfTheWeek()]);
    Serial.print(") ");
    Serial.print(now.hour(), DEC);
    Serial.print(':');
    Serial.print(now.minute(), DEC);
    Serial.print(':');
    Serial.print(now.second(), DEC);
    Serial.println();
    */
    //Serial.println("________________________________________________________________________");

